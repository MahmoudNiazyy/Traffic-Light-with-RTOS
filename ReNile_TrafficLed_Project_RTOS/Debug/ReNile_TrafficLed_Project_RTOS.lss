
ReNile_TrafficLed_Project_RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002180  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000a  00800060  00002180  00002214  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000683  0080006a  0080006a  0000221e  2**0
                  ALLOC
  3 .stab         00005034  00000000  00000000  00002220  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003536  00000000  00000000  00007254  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 43 0f 	jmp	0x1e86	; 0x1e86 <__vector_1>
       8:	0c 94 02 0f 	jmp	0x1e04	; 0x1e04 <__vector_2>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 b2 05 	jmp	0xb64	; 0xb64 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 e8       	ldi	r30, 0x80	; 128
      68:	f1 e2       	ldi	r31, 0x21	; 33
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	aa 36       	cpi	r26, 0x6A	; 106
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	aa e6       	ldi	r26, 0x6A	; 106
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ad 3e       	cpi	r26, 0xED	; 237
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 84 0f 	call	0x1f08	; 0x1f08 <main>
      8a:	0c 94 be 10 	jmp	0x217c	; 0x217c <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <GI_ENABLE>:
      92:	8f b7       	in	r24, 0x3f	; 63
      94:	80 68       	ori	r24, 0x80	; 128
      96:	8f bf       	out	0x3f, r24	; 63
      98:	08 95       	ret

0000009a <GI_DISABLE>:
	SET_BIT(SREG,I);
}

void GI_DISABLE()
{
	CLEAR_BIT(SREG,I);
      9a:	8f b7       	in	r24, 0x3f	; 63
      9c:	8f 77       	andi	r24, 0x7F	; 127
      9e:	8f bf       	out	0x3f, r24	; 63
}
      a0:	08 95       	ret

000000a2 <EXTI_SELECT_MODE>:
void (*PTR3)(void)=NULL;
//                       exti0         raising
//                       exti1         falling
void EXTI_SELECT_MODE(u8 EXTI_NAME, u8 EXTI_MODE)
{
	switch(EXTI_NAME)
      a2:	81 30       	cpi	r24, 0x01	; 1
      a4:	09 f1       	breq	.+66     	; 0xe8 <EXTI_SELECT_MODE+0x46>
      a6:	81 30       	cpi	r24, 0x01	; 1
      a8:	20 f0       	brcs	.+8      	; 0xb2 <EXTI_SELECT_MODE+0x10>
      aa:	82 30       	cpi	r24, 0x02	; 2
      ac:	09 f0       	breq	.+2      	; 0xb0 <EXTI_SELECT_MODE+0xe>
      ae:	47 c0       	rjmp	.+142    	; 0x13e <EXTI_SELECT_MODE+0x9c>
      b0:	3a c0       	rjmp	.+116    	; 0x126 <EXTI_SELECT_MODE+0x84>
	{

	case EXTI_0:
		switch(EXTI_MODE)
      b2:	61 30       	cpi	r22, 0x01	; 1
      b4:	51 f0       	breq	.+20     	; 0xca <EXTI_SELECT_MODE+0x28>
      b6:	61 30       	cpi	r22, 0x01	; 1
      b8:	28 f0       	brcs	.+10     	; 0xc4 <EXTI_SELECT_MODE+0x22>
      ba:	62 30       	cpi	r22, 0x02	; 2
      bc:	61 f0       	breq	.+24     	; 0xd6 <EXTI_SELECT_MODE+0x34>
      be:	63 30       	cpi	r22, 0x03	; 3
      c0:	f1 f5       	brne	.+124    	; 0x13e <EXTI_SELECT_MODE+0x9c>
      c2:	0c c0       	rjmp	.+24     	; 0xdc <EXTI_SELECT_MODE+0x3a>
		{
		case LOW_LEVEL:
			CLEAR_BIT(MCUCR,ISC00);
      c4:	85 b7       	in	r24, 0x35	; 53
      c6:	8e 7f       	andi	r24, 0xFE	; 254
      c8:	02 c0       	rjmp	.+4      	; 0xce <EXTI_SELECT_MODE+0x2c>
			CLEAR_BIT(MCUCR,ISC01);
			break;
		case LOGIC_CHANGE:
			SET_BIT(MCUCR,ISC00);
      ca:	85 b7       	in	r24, 0x35	; 53
      cc:	81 60       	ori	r24, 0x01	; 1
      ce:	85 bf       	out	0x35, r24	; 53
			CLEAR_BIT(MCUCR,ISC01);
      d0:	85 b7       	in	r24, 0x35	; 53
      d2:	8d 7f       	andi	r24, 0xFD	; 253
      d4:	26 c0       	rjmp	.+76     	; 0x122 <EXTI_SELECT_MODE+0x80>
			break;
		case FALLING_E:
			CLEAR_BIT(MCUCR,ISC00);
      d6:	85 b7       	in	r24, 0x35	; 53
      d8:	8e 7f       	andi	r24, 0xFE	; 254
      da:	02 c0       	rjmp	.+4      	; 0xe0 <EXTI_SELECT_MODE+0x3e>
			SET_BIT(MCUCR,ISC01);
			break;
		case RAISING_E:
			SET_BIT(MCUCR,ISC00);
      dc:	85 b7       	in	r24, 0x35	; 53
      de:	81 60       	ori	r24, 0x01	; 1
      e0:	85 bf       	out	0x35, r24	; 53
			SET_BIT(MCUCR,ISC01);
      e2:	85 b7       	in	r24, 0x35	; 53
      e4:	82 60       	ori	r24, 0x02	; 2
      e6:	1d c0       	rjmp	.+58     	; 0x122 <EXTI_SELECT_MODE+0x80>
			break;
		}
		break;

		case EXTI_1:
			switch(EXTI_MODE)
      e8:	61 30       	cpi	r22, 0x01	; 1
      ea:	69 f0       	breq	.+26     	; 0x106 <EXTI_SELECT_MODE+0x64>
      ec:	61 30       	cpi	r22, 0x01	; 1
      ee:	28 f0       	brcs	.+10     	; 0xfa <EXTI_SELECT_MODE+0x58>
      f0:	62 30       	cpi	r22, 0x02	; 2
      f2:	61 f0       	breq	.+24     	; 0x10c <EXTI_SELECT_MODE+0x6a>
      f4:	63 30       	cpi	r22, 0x03	; 3
      f6:	19 f5       	brne	.+70     	; 0x13e <EXTI_SELECT_MODE+0x9c>
      f8:	0f c0       	rjmp	.+30     	; 0x118 <EXTI_SELECT_MODE+0x76>
			{
			case LOW_LEVEL:
				CLEAR_BIT(MCUCR,ISC11);
      fa:	85 b7       	in	r24, 0x35	; 53
      fc:	87 7f       	andi	r24, 0xF7	; 247
      fe:	85 bf       	out	0x35, r24	; 53
				CLEAR_BIT(MCUCR,ISC10);
     100:	85 b7       	in	r24, 0x35	; 53
     102:	8b 7f       	andi	r24, 0xFB	; 251
     104:	0e c0       	rjmp	.+28     	; 0x122 <EXTI_SELECT_MODE+0x80>
				break;
			case LOGIC_CHANGE:
				CLEAR_BIT(MCUCR,ISC11);
     106:	85 b7       	in	r24, 0x35	; 53
     108:	87 7f       	andi	r24, 0xF7	; 247
     10a:	08 c0       	rjmp	.+16     	; 0x11c <EXTI_SELECT_MODE+0x7a>
				SET_BIT(MCUCR,ISC10);
				break;
			case FALLING_E:
				CLEAR_BIT(MCUCR,ISC10);
     10c:	85 b7       	in	r24, 0x35	; 53
     10e:	8b 7f       	andi	r24, 0xFB	; 251
     110:	85 bf       	out	0x35, r24	; 53
				SET_BIT(MCUCR,ISC11);
     112:	85 b7       	in	r24, 0x35	; 53
     114:	88 60       	ori	r24, 0x08	; 8
     116:	05 c0       	rjmp	.+10     	; 0x122 <EXTI_SELECT_MODE+0x80>
				break;
			case RAISING_E:
				SET_BIT(MCUCR,ISC11);
     118:	85 b7       	in	r24, 0x35	; 53
     11a:	88 60       	ori	r24, 0x08	; 8
     11c:	85 bf       	out	0x35, r24	; 53
				SET_BIT(MCUCR,ISC10);
     11e:	85 b7       	in	r24, 0x35	; 53
     120:	84 60       	ori	r24, 0x04	; 4
     122:	85 bf       	out	0x35, r24	; 53
     124:	08 95       	ret

			break;


			case EXTI_2:
				switch(EXTI_MODE)
     126:	62 30       	cpi	r22, 0x02	; 2
     128:	19 f0       	breq	.+6      	; 0x130 <EXTI_SELECT_MODE+0x8e>
     12a:	63 30       	cpi	r22, 0x03	; 3
     12c:	41 f4       	brne	.+16     	; 0x13e <EXTI_SELECT_MODE+0x9c>
     12e:	04 c0       	rjmp	.+8      	; 0x138 <EXTI_SELECT_MODE+0x96>
				{

				case FALLING_E:  CLEAR_BIT(MCUCSR,ISC2);  break;
     130:	84 b7       	in	r24, 0x34	; 52
     132:	8f 7b       	andi	r24, 0xBF	; 191
     134:	84 bf       	out	0x34, r24	; 52
     136:	08 95       	ret

				case RAISING_E:  SET_BIT(MCUCSR,ISC2);   break;
     138:	84 b7       	in	r24, 0x34	; 52
     13a:	80 64       	ori	r24, 0x40	; 64
     13c:	84 bf       	out	0x34, r24	; 52
     13e:	08 95       	ret

00000140 <EXTI_SELECT_INTERRUBT_ENABLE>:
}


void EXTI_SELECT_INTERRUBT_ENABLE(u8 EXTI_NAME)
{
	switch(EXTI_NAME)
     140:	81 30       	cpi	r24, 0x01	; 1
     142:	41 f0       	breq	.+16     	; 0x154 <EXTI_SELECT_INTERRUBT_ENABLE+0x14>
     144:	81 30       	cpi	r24, 0x01	; 1
     146:	18 f0       	brcs	.+6      	; 0x14e <EXTI_SELECT_INTERRUBT_ENABLE+0xe>
     148:	82 30       	cpi	r24, 0x02	; 2
     14a:	59 f4       	brne	.+22     	; 0x162 <EXTI_SELECT_INTERRUBT_ENABLE+0x22>
     14c:	07 c0       	rjmp	.+14     	; 0x15c <EXTI_SELECT_INTERRUBT_ENABLE+0x1c>
	{
	case EXTI_0:  SET_BIT(GICR,INT0);  break;
     14e:	8b b7       	in	r24, 0x3b	; 59
     150:	80 64       	ori	r24, 0x40	; 64
     152:	02 c0       	rjmp	.+4      	; 0x158 <EXTI_SELECT_INTERRUBT_ENABLE+0x18>


	case EXTI_1: SET_BIT(GICR,INT1);  break;
     154:	8b b7       	in	r24, 0x3b	; 59
     156:	80 68       	ori	r24, 0x80	; 128
     158:	8b bf       	out	0x3b, r24	; 59
     15a:	08 95       	ret



	case EXTI_2: SET_BIT(GICR,INT2);   break;
     15c:	8b b7       	in	r24, 0x3b	; 59
     15e:	80 62       	ori	r24, 0x20	; 32
     160:	8b bf       	out	0x3b, r24	; 59
     162:	08 95       	ret

00000164 <EXTI_SELECT_INTERRUBT_DISABLE>:

}

void EXTI_SELECT_INTERRUBT_DISABLE(u8 EXTI_NAME)
{
	switch(EXTI_NAME)
     164:	81 30       	cpi	r24, 0x01	; 1
     166:	41 f0       	breq	.+16     	; 0x178 <EXTI_SELECT_INTERRUBT_DISABLE+0x14>
     168:	81 30       	cpi	r24, 0x01	; 1
     16a:	18 f0       	brcs	.+6      	; 0x172 <EXTI_SELECT_INTERRUBT_DISABLE+0xe>
     16c:	82 30       	cpi	r24, 0x02	; 2
     16e:	59 f4       	brne	.+22     	; 0x186 <EXTI_SELECT_INTERRUBT_DISABLE+0x22>
     170:	07 c0       	rjmp	.+14     	; 0x180 <EXTI_SELECT_INTERRUBT_DISABLE+0x1c>
	{
	case EXTI_0:  CLEAR_BIT(GICR,INT0);  break;
     172:	8b b7       	in	r24, 0x3b	; 59
     174:	8f 7b       	andi	r24, 0xBF	; 191
     176:	02 c0       	rjmp	.+4      	; 0x17c <EXTI_SELECT_INTERRUBT_DISABLE+0x18>


	case EXTI_1: CLEAR_BIT(GICR,INT1);  break;
     178:	8b b7       	in	r24, 0x3b	; 59
     17a:	8f 77       	andi	r24, 0x7F	; 127
     17c:	8b bf       	out	0x3b, r24	; 59
     17e:	08 95       	ret



	case EXTI_2: CLEAR_BIT(GICR,INT2);   break;
     180:	8b b7       	in	r24, 0x3b	; 59
     182:	8f 7d       	andi	r24, 0xDF	; 223
     184:	8b bf       	out	0x3b, r24	; 59
     186:	08 95       	ret

00000188 <EXTI_READ_FLAG>:
u8 EXTI_READ_FLAG(u8 EXTI_NAME)
{
	u8 read = 0;


	switch(EXTI_NAME)
     188:	81 30       	cpi	r24, 0x01	; 1
     18a:	61 f0       	breq	.+24     	; 0x1a4 <EXTI_READ_FLAG+0x1c>
     18c:	81 30       	cpi	r24, 0x01	; 1
     18e:	20 f0       	brcs	.+8      	; 0x198 <EXTI_READ_FLAG+0x10>
     190:	82 30       	cpi	r24, 0x02	; 2
     192:	69 f0       	breq	.+26     	; 0x1ae <EXTI_READ_FLAG+0x26>
     194:	80 e0       	ldi	r24, 0x00	; 0
     196:	08 95       	ret
	{
	case EXTI_0:   read= GET_BIT(GIFR,INTF0); break;
     198:	8a b7       	in	r24, 0x3a	; 58
     19a:	82 95       	swap	r24
     19c:	86 95       	lsr	r24
     19e:	86 95       	lsr	r24
     1a0:	81 70       	andi	r24, 0x01	; 1
     1a2:	08 95       	ret


	case EXTI_1:  read= GET_BIT(GIFR,INTF1); break;
     1a4:	8a b7       	in	r24, 0x3a	; 58
     1a6:	88 1f       	adc	r24, r24
     1a8:	88 27       	eor	r24, r24
     1aa:	88 1f       	adc	r24, r24
     1ac:	08 95       	ret



	case EXTI_2:  read= GET_BIT(GIFR,INTF2);  break;
     1ae:	8a b7       	in	r24, 0x3a	; 58
     1b0:	82 95       	swap	r24
     1b2:	86 95       	lsr	r24
     1b4:	81 70       	andi	r24, 0x01	; 1
	}

	return read;
}
     1b6:	08 95       	ret

000001b8 <ISR_EXTI0>:

void ISR_EXTI0(void (*FPTR)(void))
{
	PTR1=FPTR;
     1b8:	90 93 6b 00 	sts	0x006B, r25
     1bc:	80 93 6a 00 	sts	0x006A, r24
}
     1c0:	08 95       	ret

000001c2 <ISR_EXTI1>:


void ISR_EXTI1(void (*FPTR)(void))
{
	PTR2=FPTR;
     1c2:	90 93 6d 00 	sts	0x006D, r25
     1c6:	80 93 6c 00 	sts	0x006C, r24
}
     1ca:	08 95       	ret

000001cc <ISR_EXTI2>:
void ISR_EXTI2(void (*FPTR)(void))
{
	PTR3=FPTR;
     1cc:	90 93 6f 00 	sts	0x006F, r25
     1d0:	80 93 6e 00 	sts	0x006E, r24
}
     1d4:	08 95       	ret

000001d6 <vSET_PIN_DIRECTION>:
#include <avr/io.h>
#include "DIO_INTERFACE.h"
//    EX                  PORT_A         PIN_5        INPUT
void vSET_PIN_DIRECTION(u8 PORT_NUM , u8 PIN_NUM , u8 DIRECTION)
{
	switch(DIRECTION)
     1d6:	44 23       	and	r20, r20
     1d8:	c9 f1       	breq	.+114    	; 0x24c <vSET_PIN_DIRECTION+0x76>
     1da:	41 30       	cpi	r20, 0x01	; 1
     1dc:	09 f0       	breq	.+2      	; 0x1e0 <vSET_PIN_DIRECTION+0xa>
     1de:	6e c0       	rjmp	.+220    	; 0x2bc <vSET_PIN_DIRECTION+0xe6>
	{
	case OUTPUT:

		switch(PORT_NUM)
     1e0:	81 30       	cpi	r24, 0x01	; 1
     1e2:	99 f0       	breq	.+38     	; 0x20a <vSET_PIN_DIRECTION+0x34>
     1e4:	81 30       	cpi	r24, 0x01	; 1
     1e6:	30 f0       	brcs	.+12     	; 0x1f4 <vSET_PIN_DIRECTION+0x1e>
     1e8:	82 30       	cpi	r24, 0x02	; 2
     1ea:	d1 f0       	breq	.+52     	; 0x220 <vSET_PIN_DIRECTION+0x4a>
     1ec:	83 30       	cpi	r24, 0x03	; 3
     1ee:	09 f0       	breq	.+2      	; 0x1f2 <vSET_PIN_DIRECTION+0x1c>
     1f0:	65 c0       	rjmp	.+202    	; 0x2bc <vSET_PIN_DIRECTION+0xe6>
     1f2:	21 c0       	rjmp	.+66     	; 0x236 <vSET_PIN_DIRECTION+0x60>
		{
		case PORT_A: SET_BIT(DDRA,PIN_NUM); break;
     1f4:	2a b3       	in	r18, 0x1a	; 26
     1f6:	81 e0       	ldi	r24, 0x01	; 1
     1f8:	90 e0       	ldi	r25, 0x00	; 0
     1fa:	02 c0       	rjmp	.+4      	; 0x200 <vSET_PIN_DIRECTION+0x2a>
     1fc:	88 0f       	add	r24, r24
     1fe:	99 1f       	adc	r25, r25
     200:	6a 95       	dec	r22
     202:	e2 f7       	brpl	.-8      	; 0x1fc <vSET_PIN_DIRECTION+0x26>
     204:	28 2b       	or	r18, r24
     206:	2a bb       	out	0x1a, r18	; 26
     208:	08 95       	ret
		case PORT_B: SET_BIT(DDRB,PIN_NUM); break;
     20a:	27 b3       	in	r18, 0x17	; 23
     20c:	81 e0       	ldi	r24, 0x01	; 1
     20e:	90 e0       	ldi	r25, 0x00	; 0
     210:	02 c0       	rjmp	.+4      	; 0x216 <vSET_PIN_DIRECTION+0x40>
     212:	88 0f       	add	r24, r24
     214:	99 1f       	adc	r25, r25
     216:	6a 95       	dec	r22
     218:	e2 f7       	brpl	.-8      	; 0x212 <vSET_PIN_DIRECTION+0x3c>
     21a:	28 2b       	or	r18, r24
     21c:	27 bb       	out	0x17, r18	; 23
     21e:	08 95       	ret
		case PORT_C: SET_BIT(DDRC,PIN_NUM); break;
     220:	24 b3       	in	r18, 0x14	; 20
     222:	81 e0       	ldi	r24, 0x01	; 1
     224:	90 e0       	ldi	r25, 0x00	; 0
     226:	02 c0       	rjmp	.+4      	; 0x22c <vSET_PIN_DIRECTION+0x56>
     228:	88 0f       	add	r24, r24
     22a:	99 1f       	adc	r25, r25
     22c:	6a 95       	dec	r22
     22e:	e2 f7       	brpl	.-8      	; 0x228 <vSET_PIN_DIRECTION+0x52>
     230:	28 2b       	or	r18, r24
     232:	24 bb       	out	0x14, r18	; 20
     234:	08 95       	ret
		case PORT_D: SET_BIT(DDRD,PIN_NUM); break;
     236:	21 b3       	in	r18, 0x11	; 17
     238:	81 e0       	ldi	r24, 0x01	; 1
     23a:	90 e0       	ldi	r25, 0x00	; 0
     23c:	02 c0       	rjmp	.+4      	; 0x242 <vSET_PIN_DIRECTION+0x6c>
     23e:	88 0f       	add	r24, r24
     240:	99 1f       	adc	r25, r25
     242:	6a 95       	dec	r22
     244:	e2 f7       	brpl	.-8      	; 0x23e <vSET_PIN_DIRECTION+0x68>
     246:	28 2b       	or	r18, r24
     248:	21 bb       	out	0x11, r18	; 17
     24a:	08 95       	ret



		case INPUT:

			switch(PORT_NUM)
     24c:	81 30       	cpi	r24, 0x01	; 1
     24e:	99 f0       	breq	.+38     	; 0x276 <vSET_PIN_DIRECTION+0xa0>
     250:	81 30       	cpi	r24, 0x01	; 1
     252:	28 f0       	brcs	.+10     	; 0x25e <vSET_PIN_DIRECTION+0x88>
     254:	82 30       	cpi	r24, 0x02	; 2
     256:	d9 f0       	breq	.+54     	; 0x28e <vSET_PIN_DIRECTION+0xb8>
     258:	83 30       	cpi	r24, 0x03	; 3
     25a:	81 f5       	brne	.+96     	; 0x2bc <vSET_PIN_DIRECTION+0xe6>
     25c:	24 c0       	rjmp	.+72     	; 0x2a6 <vSET_PIN_DIRECTION+0xd0>
			{
			case PORT_A: CLEAR_BIT(DDRA,PIN_NUM); break;
     25e:	2a b3       	in	r18, 0x1a	; 26
     260:	81 e0       	ldi	r24, 0x01	; 1
     262:	90 e0       	ldi	r25, 0x00	; 0
     264:	02 c0       	rjmp	.+4      	; 0x26a <vSET_PIN_DIRECTION+0x94>
     266:	88 0f       	add	r24, r24
     268:	99 1f       	adc	r25, r25
     26a:	6a 95       	dec	r22
     26c:	e2 f7       	brpl	.-8      	; 0x266 <vSET_PIN_DIRECTION+0x90>
     26e:	80 95       	com	r24
     270:	82 23       	and	r24, r18
     272:	8a bb       	out	0x1a, r24	; 26
     274:	08 95       	ret
			case PORT_B: CLEAR_BIT(DDRB,PIN_NUM); break;
     276:	27 b3       	in	r18, 0x17	; 23
     278:	81 e0       	ldi	r24, 0x01	; 1
     27a:	90 e0       	ldi	r25, 0x00	; 0
     27c:	02 c0       	rjmp	.+4      	; 0x282 <vSET_PIN_DIRECTION+0xac>
     27e:	88 0f       	add	r24, r24
     280:	99 1f       	adc	r25, r25
     282:	6a 95       	dec	r22
     284:	e2 f7       	brpl	.-8      	; 0x27e <vSET_PIN_DIRECTION+0xa8>
     286:	80 95       	com	r24
     288:	82 23       	and	r24, r18
     28a:	87 bb       	out	0x17, r24	; 23
     28c:	08 95       	ret
			case PORT_C: CLEAR_BIT(DDRC,PIN_NUM); break;
     28e:	24 b3       	in	r18, 0x14	; 20
     290:	81 e0       	ldi	r24, 0x01	; 1
     292:	90 e0       	ldi	r25, 0x00	; 0
     294:	02 c0       	rjmp	.+4      	; 0x29a <vSET_PIN_DIRECTION+0xc4>
     296:	88 0f       	add	r24, r24
     298:	99 1f       	adc	r25, r25
     29a:	6a 95       	dec	r22
     29c:	e2 f7       	brpl	.-8      	; 0x296 <vSET_PIN_DIRECTION+0xc0>
     29e:	80 95       	com	r24
     2a0:	82 23       	and	r24, r18
     2a2:	84 bb       	out	0x14, r24	; 20
     2a4:	08 95       	ret
			case PORT_D: CLEAR_BIT(DDRD,PIN_NUM); break;
     2a6:	21 b3       	in	r18, 0x11	; 17
     2a8:	81 e0       	ldi	r24, 0x01	; 1
     2aa:	90 e0       	ldi	r25, 0x00	; 0
     2ac:	02 c0       	rjmp	.+4      	; 0x2b2 <vSET_PIN_DIRECTION+0xdc>
     2ae:	88 0f       	add	r24, r24
     2b0:	99 1f       	adc	r25, r25
     2b2:	6a 95       	dec	r22
     2b4:	e2 f7       	brpl	.-8      	; 0x2ae <vSET_PIN_DIRECTION+0xd8>
     2b6:	80 95       	com	r24
     2b8:	82 23       	and	r24, r18
     2ba:	81 bb       	out	0x11, r24	; 17
     2bc:	08 95       	ret

000002be <vSET_PIN_OUTPUT_VALUE>:


//   EX                    PORT_A         PIN_5        LOW
void vSET_PIN_OUTPUT_VALUE(u8 PORT_NUM,u8 PIN_NUM,u8 OUTPUT_VALUE)
{
	switch(OUTPUT_VALUE)
     2be:	44 23       	and	r20, r20
     2c0:	c9 f1       	breq	.+114    	; 0x334 <vSET_PIN_OUTPUT_VALUE+0x76>
     2c2:	41 30       	cpi	r20, 0x01	; 1
     2c4:	09 f0       	breq	.+2      	; 0x2c8 <vSET_PIN_OUTPUT_VALUE+0xa>
     2c6:	6e c0       	rjmp	.+220    	; 0x3a4 <vSET_PIN_OUTPUT_VALUE+0xe6>
	{
	case HIGH:
		switch(PORT_NUM)
     2c8:	81 30       	cpi	r24, 0x01	; 1
     2ca:	99 f0       	breq	.+38     	; 0x2f2 <vSET_PIN_OUTPUT_VALUE+0x34>
     2cc:	81 30       	cpi	r24, 0x01	; 1
     2ce:	30 f0       	brcs	.+12     	; 0x2dc <vSET_PIN_OUTPUT_VALUE+0x1e>
     2d0:	82 30       	cpi	r24, 0x02	; 2
     2d2:	d1 f0       	breq	.+52     	; 0x308 <vSET_PIN_OUTPUT_VALUE+0x4a>
     2d4:	83 30       	cpi	r24, 0x03	; 3
     2d6:	09 f0       	breq	.+2      	; 0x2da <vSET_PIN_OUTPUT_VALUE+0x1c>
     2d8:	65 c0       	rjmp	.+202    	; 0x3a4 <vSET_PIN_OUTPUT_VALUE+0xe6>
     2da:	21 c0       	rjmp	.+66     	; 0x31e <vSET_PIN_OUTPUT_VALUE+0x60>
		{
		case PORT_A : SET_BIT(PORTA,PIN_NUM);  break;
     2dc:	2b b3       	in	r18, 0x1b	; 27
     2de:	81 e0       	ldi	r24, 0x01	; 1
     2e0:	90 e0       	ldi	r25, 0x00	; 0
     2e2:	02 c0       	rjmp	.+4      	; 0x2e8 <vSET_PIN_OUTPUT_VALUE+0x2a>
     2e4:	88 0f       	add	r24, r24
     2e6:	99 1f       	adc	r25, r25
     2e8:	6a 95       	dec	r22
     2ea:	e2 f7       	brpl	.-8      	; 0x2e4 <vSET_PIN_OUTPUT_VALUE+0x26>
     2ec:	28 2b       	or	r18, r24
     2ee:	2b bb       	out	0x1b, r18	; 27
     2f0:	08 95       	ret
		case PORT_B : SET_BIT(PORTB,PIN_NUM);  break;
     2f2:	28 b3       	in	r18, 0x18	; 24
     2f4:	81 e0       	ldi	r24, 0x01	; 1
     2f6:	90 e0       	ldi	r25, 0x00	; 0
     2f8:	02 c0       	rjmp	.+4      	; 0x2fe <vSET_PIN_OUTPUT_VALUE+0x40>
     2fa:	88 0f       	add	r24, r24
     2fc:	99 1f       	adc	r25, r25
     2fe:	6a 95       	dec	r22
     300:	e2 f7       	brpl	.-8      	; 0x2fa <vSET_PIN_OUTPUT_VALUE+0x3c>
     302:	28 2b       	or	r18, r24
     304:	28 bb       	out	0x18, r18	; 24
     306:	08 95       	ret
		case PORT_C : SET_BIT(PORTC,PIN_NUM);  break;
     308:	25 b3       	in	r18, 0x15	; 21
     30a:	81 e0       	ldi	r24, 0x01	; 1
     30c:	90 e0       	ldi	r25, 0x00	; 0
     30e:	02 c0       	rjmp	.+4      	; 0x314 <vSET_PIN_OUTPUT_VALUE+0x56>
     310:	88 0f       	add	r24, r24
     312:	99 1f       	adc	r25, r25
     314:	6a 95       	dec	r22
     316:	e2 f7       	brpl	.-8      	; 0x310 <vSET_PIN_OUTPUT_VALUE+0x52>
     318:	28 2b       	or	r18, r24
     31a:	25 bb       	out	0x15, r18	; 21
     31c:	08 95       	ret
		case PORT_D : SET_BIT(PORTD,PIN_NUM);  break;
     31e:	22 b3       	in	r18, 0x12	; 18
     320:	81 e0       	ldi	r24, 0x01	; 1
     322:	90 e0       	ldi	r25, 0x00	; 0
     324:	02 c0       	rjmp	.+4      	; 0x32a <vSET_PIN_OUTPUT_VALUE+0x6c>
     326:	88 0f       	add	r24, r24
     328:	99 1f       	adc	r25, r25
     32a:	6a 95       	dec	r22
     32c:	e2 f7       	brpl	.-8      	; 0x326 <vSET_PIN_OUTPUT_VALUE+0x68>
     32e:	28 2b       	or	r18, r24
     330:	22 bb       	out	0x12, r18	; 18
     332:	08 95       	ret

		break;

		case LOW:

			switch(PORT_NUM)
     334:	81 30       	cpi	r24, 0x01	; 1
     336:	99 f0       	breq	.+38     	; 0x35e <vSET_PIN_OUTPUT_VALUE+0xa0>
     338:	81 30       	cpi	r24, 0x01	; 1
     33a:	28 f0       	brcs	.+10     	; 0x346 <vSET_PIN_OUTPUT_VALUE+0x88>
     33c:	82 30       	cpi	r24, 0x02	; 2
     33e:	d9 f0       	breq	.+54     	; 0x376 <vSET_PIN_OUTPUT_VALUE+0xb8>
     340:	83 30       	cpi	r24, 0x03	; 3
     342:	81 f5       	brne	.+96     	; 0x3a4 <vSET_PIN_OUTPUT_VALUE+0xe6>
     344:	24 c0       	rjmp	.+72     	; 0x38e <vSET_PIN_OUTPUT_VALUE+0xd0>
			{
			case PORT_A : CLEAR_BIT(PORTA,PIN_NUM);  break;
     346:	2b b3       	in	r18, 0x1b	; 27
     348:	81 e0       	ldi	r24, 0x01	; 1
     34a:	90 e0       	ldi	r25, 0x00	; 0
     34c:	02 c0       	rjmp	.+4      	; 0x352 <vSET_PIN_OUTPUT_VALUE+0x94>
     34e:	88 0f       	add	r24, r24
     350:	99 1f       	adc	r25, r25
     352:	6a 95       	dec	r22
     354:	e2 f7       	brpl	.-8      	; 0x34e <vSET_PIN_OUTPUT_VALUE+0x90>
     356:	80 95       	com	r24
     358:	82 23       	and	r24, r18
     35a:	8b bb       	out	0x1b, r24	; 27
     35c:	08 95       	ret
			case PORT_B : CLEAR_BIT(PORTB,PIN_NUM);  break;
     35e:	28 b3       	in	r18, 0x18	; 24
     360:	81 e0       	ldi	r24, 0x01	; 1
     362:	90 e0       	ldi	r25, 0x00	; 0
     364:	02 c0       	rjmp	.+4      	; 0x36a <vSET_PIN_OUTPUT_VALUE+0xac>
     366:	88 0f       	add	r24, r24
     368:	99 1f       	adc	r25, r25
     36a:	6a 95       	dec	r22
     36c:	e2 f7       	brpl	.-8      	; 0x366 <vSET_PIN_OUTPUT_VALUE+0xa8>
     36e:	80 95       	com	r24
     370:	82 23       	and	r24, r18
     372:	88 bb       	out	0x18, r24	; 24
     374:	08 95       	ret
			case PORT_C : CLEAR_BIT(PORTC,PIN_NUM);  break;
     376:	25 b3       	in	r18, 0x15	; 21
     378:	81 e0       	ldi	r24, 0x01	; 1
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	02 c0       	rjmp	.+4      	; 0x382 <vSET_PIN_OUTPUT_VALUE+0xc4>
     37e:	88 0f       	add	r24, r24
     380:	99 1f       	adc	r25, r25
     382:	6a 95       	dec	r22
     384:	e2 f7       	brpl	.-8      	; 0x37e <vSET_PIN_OUTPUT_VALUE+0xc0>
     386:	80 95       	com	r24
     388:	82 23       	and	r24, r18
     38a:	85 bb       	out	0x15, r24	; 21
     38c:	08 95       	ret
			case PORT_D : CLEAR_BIT(PORTD,PIN_NUM);  break;
     38e:	22 b3       	in	r18, 0x12	; 18
     390:	81 e0       	ldi	r24, 0x01	; 1
     392:	90 e0       	ldi	r25, 0x00	; 0
     394:	02 c0       	rjmp	.+4      	; 0x39a <vSET_PIN_OUTPUT_VALUE+0xdc>
     396:	88 0f       	add	r24, r24
     398:	99 1f       	adc	r25, r25
     39a:	6a 95       	dec	r22
     39c:	e2 f7       	brpl	.-8      	; 0x396 <vSET_PIN_OUTPUT_VALUE+0xd8>
     39e:	80 95       	com	r24
     3a0:	82 23       	and	r24, r18
     3a2:	82 bb       	out	0x12, r24	; 18
     3a4:	08 95       	ret

000003a6 <u8READ_PIN>:

//   EX          PORT_A         PIN_5
u8 u8READ_PIN(u8 PORT_NUM,u8 PIN_NUM)
{
	u8 read=0;
	switch(PORT_NUM)
     3a6:	81 30       	cpi	r24, 0x01	; 1
     3a8:	51 f0       	breq	.+20     	; 0x3be <u8READ_PIN+0x18>
     3aa:	81 30       	cpi	r24, 0x01	; 1
     3ac:	30 f0       	brcs	.+12     	; 0x3ba <u8READ_PIN+0x14>
     3ae:	82 30       	cpi	r24, 0x02	; 2
     3b0:	41 f0       	breq	.+16     	; 0x3c2 <u8READ_PIN+0x1c>
     3b2:	83 30       	cpi	r24, 0x03	; 3
     3b4:	79 f0       	breq	.+30     	; 0x3d4 <u8READ_PIN+0x2e>
     3b6:	80 e0       	ldi	r24, 0x00	; 0
     3b8:	08 95       	ret
	{
	case PORT_A: read = GET_BIT(PINA,PIN_NUM); break;
     3ba:	89 b3       	in	r24, 0x19	; 25
     3bc:	03 c0       	rjmp	.+6      	; 0x3c4 <u8READ_PIN+0x1e>
	case PORT_B: read = GET_BIT(PINB,PIN_NUM);break;
     3be:	86 b3       	in	r24, 0x16	; 22
     3c0:	01 c0       	rjmp	.+2      	; 0x3c4 <u8READ_PIN+0x1e>
	case PORT_C:read = GET_BIT(PINC,PIN_NUM); break;
     3c2:	83 b3       	in	r24, 0x13	; 19
     3c4:	90 e0       	ldi	r25, 0x00	; 0
     3c6:	02 c0       	rjmp	.+4      	; 0x3cc <u8READ_PIN+0x26>
     3c8:	95 95       	asr	r25
     3ca:	87 95       	ror	r24
     3cc:	6a 95       	dec	r22
     3ce:	e2 f7       	brpl	.-8      	; 0x3c8 <u8READ_PIN+0x22>
     3d0:	81 70       	andi	r24, 0x01	; 1
     3d2:	08 95       	ret
	case PORT_D: read = GET_BIT(PIND,PIN_NUM);break;
     3d4:	80 b3       	in	r24, 0x10	; 16
     3d6:	90 e0       	ldi	r25, 0x00	; 0
     3d8:	02 c0       	rjmp	.+4      	; 0x3de <u8READ_PIN+0x38>
     3da:	95 95       	asr	r25
     3dc:	87 95       	ror	r24
     3de:	6a 95       	dec	r22
     3e0:	e2 f7       	brpl	.-8      	; 0x3da <u8READ_PIN+0x34>
     3e2:	81 70       	andi	r24, 0x01	; 1

	}
	return read ;
}
     3e4:	08 95       	ret

000003e6 <vToggel_PIN>:


//   EX          PORT_A         PIN_5
void vToggel_PIN(u8 PORT_NUM,u8 PIN_NUM)
{
	switch(PORT_NUM)
     3e6:	81 30       	cpi	r24, 0x01	; 1
     3e8:	91 f0       	breq	.+36     	; 0x40e <vToggel_PIN+0x28>
     3ea:	81 30       	cpi	r24, 0x01	; 1
     3ec:	28 f0       	brcs	.+10     	; 0x3f8 <vToggel_PIN+0x12>
     3ee:	82 30       	cpi	r24, 0x02	; 2
     3f0:	c9 f0       	breq	.+50     	; 0x424 <vToggel_PIN+0x3e>
     3f2:	83 30       	cpi	r24, 0x03	; 3
     3f4:	61 f5       	brne	.+88     	; 0x44e <vToggel_PIN+0x68>
     3f6:	21 c0       	rjmp	.+66     	; 0x43a <vToggel_PIN+0x54>
	{
	case PORT_A: TOG_BIT(PORTA,PIN_NUM); break;
     3f8:	2b b3       	in	r18, 0x1b	; 27
     3fa:	81 e0       	ldi	r24, 0x01	; 1
     3fc:	90 e0       	ldi	r25, 0x00	; 0
     3fe:	02 c0       	rjmp	.+4      	; 0x404 <vToggel_PIN+0x1e>
     400:	88 0f       	add	r24, r24
     402:	99 1f       	adc	r25, r25
     404:	6a 95       	dec	r22
     406:	e2 f7       	brpl	.-8      	; 0x400 <vToggel_PIN+0x1a>
     408:	28 27       	eor	r18, r24
     40a:	2b bb       	out	0x1b, r18	; 27
     40c:	08 95       	ret
	case PORT_B:TOG_BIT(PORTB,PIN_NUM); break;
     40e:	28 b3       	in	r18, 0x18	; 24
     410:	81 e0       	ldi	r24, 0x01	; 1
     412:	90 e0       	ldi	r25, 0x00	; 0
     414:	02 c0       	rjmp	.+4      	; 0x41a <vToggel_PIN+0x34>
     416:	88 0f       	add	r24, r24
     418:	99 1f       	adc	r25, r25
     41a:	6a 95       	dec	r22
     41c:	e2 f7       	brpl	.-8      	; 0x416 <vToggel_PIN+0x30>
     41e:	28 27       	eor	r18, r24
     420:	28 bb       	out	0x18, r18	; 24
     422:	08 95       	ret
	case PORT_C: TOG_BIT(PORTC,PIN_NUM);break;
     424:	25 b3       	in	r18, 0x15	; 21
     426:	81 e0       	ldi	r24, 0x01	; 1
     428:	90 e0       	ldi	r25, 0x00	; 0
     42a:	02 c0       	rjmp	.+4      	; 0x430 <vToggel_PIN+0x4a>
     42c:	88 0f       	add	r24, r24
     42e:	99 1f       	adc	r25, r25
     430:	6a 95       	dec	r22
     432:	e2 f7       	brpl	.-8      	; 0x42c <vToggel_PIN+0x46>
     434:	28 27       	eor	r18, r24
     436:	25 bb       	out	0x15, r18	; 21
     438:	08 95       	ret
	case PORT_D:TOG_BIT(PORTD,PIN_NUM); break;
     43a:	22 b3       	in	r18, 0x12	; 18
     43c:	81 e0       	ldi	r24, 0x01	; 1
     43e:	90 e0       	ldi	r25, 0x00	; 0
     440:	02 c0       	rjmp	.+4      	; 0x446 <vToggel_PIN+0x60>
     442:	88 0f       	add	r24, r24
     444:	99 1f       	adc	r25, r25
     446:	6a 95       	dec	r22
     448:	e2 f7       	brpl	.-8      	; 0x442 <vToggel_PIN+0x5c>
     44a:	28 27       	eor	r18, r24
     44c:	22 bb       	out	0x12, r18	; 18
     44e:	08 95       	ret

00000450 <vSET_PORT_DIRECTION>:

//  EX                       PORT_A        0x0f|0xf0 | 36
void vSET_PORT_DIRECTION(u8 PORT_NUM, u8 DIRECTION_value)
{

	switch(PORT_NUM)
     450:	81 30       	cpi	r24, 0x01	; 1
     452:	49 f0       	breq	.+18     	; 0x466 <vSET_PORT_DIRECTION+0x16>
     454:	81 30       	cpi	r24, 0x01	; 1
     456:	28 f0       	brcs	.+10     	; 0x462 <vSET_PORT_DIRECTION+0x12>
     458:	82 30       	cpi	r24, 0x02	; 2
     45a:	39 f0       	breq	.+14     	; 0x46a <vSET_PORT_DIRECTION+0x1a>
     45c:	83 30       	cpi	r24, 0x03	; 3
     45e:	41 f4       	brne	.+16     	; 0x470 <vSET_PORT_DIRECTION+0x20>
     460:	06 c0       	rjmp	.+12     	; 0x46e <vSET_PORT_DIRECTION+0x1e>
	{
	case PORT_A :    DDRA = DIRECTION_value; break;
     462:	6a bb       	out	0x1a, r22	; 26
     464:	08 95       	ret
	case PORT_B : 	 DDRB = DIRECTION_value; break;
     466:	67 bb       	out	0x17, r22	; 23
     468:	08 95       	ret
	case PORT_C : 	 DDRC = DIRECTION_value;break;
     46a:	64 bb       	out	0x14, r22	; 20
     46c:	08 95       	ret
	case PORT_D :	 DDRD = DIRECTION_value;  break;
     46e:	61 bb       	out	0x11, r22	; 17
     470:	08 95       	ret

00000472 <vSET_PORT_OUTPUT_VALUE>:


//   EX                       PORT_A       0x0f|0xf0 | 36
void vSET_PORT_OUTPUT_VALUE(u8 PORT_NUM,u8 OUTPUT_VALUE)
{
	switch(PORT_NUM)
     472:	81 30       	cpi	r24, 0x01	; 1
     474:	49 f0       	breq	.+18     	; 0x488 <vSET_PORT_OUTPUT_VALUE+0x16>
     476:	81 30       	cpi	r24, 0x01	; 1
     478:	28 f0       	brcs	.+10     	; 0x484 <vSET_PORT_OUTPUT_VALUE+0x12>
     47a:	82 30       	cpi	r24, 0x02	; 2
     47c:	39 f0       	breq	.+14     	; 0x48c <vSET_PORT_OUTPUT_VALUE+0x1a>
     47e:	83 30       	cpi	r24, 0x03	; 3
     480:	41 f4       	brne	.+16     	; 0x492 <vSET_PORT_OUTPUT_VALUE+0x20>
     482:	06 c0       	rjmp	.+12     	; 0x490 <vSET_PORT_OUTPUT_VALUE+0x1e>
	{
	case PORT_A :    PORTA = OUTPUT_VALUE; break;
     484:	6b bb       	out	0x1b, r22	; 27
     486:	08 95       	ret
	case PORT_B : 	 PORTB = OUTPUT_VALUE; break;
     488:	68 bb       	out	0x18, r22	; 24
     48a:	08 95       	ret
	case PORT_C : 	 PORTC = OUTPUT_VALUE;break;
     48c:	65 bb       	out	0x15, r22	; 21
     48e:	08 95       	ret
	case PORT_D :	 PORTD = OUTPUT_VALUE;  break;
     490:	62 bb       	out	0x12, r22	; 18
     492:	08 95       	ret

00000494 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     494:	ef 92       	push	r14
     496:	ff 92       	push	r15
     498:	0f 93       	push	r16
     49a:	1f 93       	push	r17
     49c:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     49e:	05 80       	ldd	r0, Z+5	; 0x05
     4a0:	f6 81       	ldd	r31, Z+6	; 0x06
     4a2:	e0 2d       	mov	r30, r0
     4a4:	e6 80       	ldd	r14, Z+6	; 0x06
     4a6:	f7 80       	ldd	r15, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     4a8:	87 01       	movw	r16, r14
     4aa:	04 5f       	subi	r16, 0xF4	; 244
     4ac:	1f 4f       	sbci	r17, 0xFF	; 255
     4ae:	c8 01       	movw	r24, r16
     4b0:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     4b4:	81 ea       	ldi	r24, 0xA1	; 161
     4b6:	90 e0       	ldi	r25, 0x00	; 0
     4b8:	b8 01       	movw	r22, r16
     4ba:	0e 94 53 04 	call	0x8a6	; 0x8a6 <vListInsertEnd>
     4be:	20 e0       	ldi	r18, 0x00	; 0
     4c0:	e0 91 70 00 	lds	r30, 0x0070
     4c4:	f0 91 71 00 	lds	r31, 0x0071
     4c8:	d7 01       	movw	r26, r14
     4ca:	56 96       	adiw	r26, 0x16	; 22
     4cc:	9c 91       	ld	r25, X
     4ce:	86 89       	ldd	r24, Z+22	; 0x16
     4d0:	98 17       	cp	r25, r24
     4d2:	08 f0       	brcs	.+2      	; 0x4d6 <xCoRoutineRemoveFromEventList+0x42>
     4d4:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     4d6:	82 2f       	mov	r24, r18
     4d8:	1f 91       	pop	r17
     4da:	0f 91       	pop	r16
     4dc:	ff 90       	pop	r15
     4de:	ef 90       	pop	r14
     4e0:	08 95       	ret

000004e2 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     4e2:	ff 92       	push	r15
     4e4:	0f 93       	push	r16
     4e6:	1f 93       	push	r17
     4e8:	cf 93       	push	r28
     4ea:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     4ec:	99 e0       	ldi	r25, 0x09	; 9
     4ee:	f9 2e       	mov	r15, r25
     4f0:	21 c0       	rjmp	.+66     	; 0x534 <vCoRoutineSchedule+0x52>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     4f2:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     4f4:	e0 91 a6 00 	lds	r30, 0x00A6
     4f8:	f0 91 a7 00 	lds	r31, 0x00A7
     4fc:	06 81       	ldd	r16, Z+6	; 0x06
     4fe:	17 81       	ldd	r17, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     500:	c8 01       	movw	r24, r16
     502:	0c 96       	adiw	r24, 0x0c	; 12
     504:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     508:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     50a:	e8 01       	movw	r28, r16
     50c:	22 96       	adiw	r28, 0x02	; 2
     50e:	ce 01       	movw	r24, r28
     510:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     514:	f8 01       	movw	r30, r16
     516:	96 89       	ldd	r25, Z+22	; 0x16
     518:	80 91 72 00 	lds	r24, 0x0072
     51c:	89 17       	cp	r24, r25
     51e:	10 f4       	brcc	.+4      	; 0x524 <vCoRoutineSchedule+0x42>
     520:	90 93 72 00 	sts	0x0072, r25
     524:	9f 9d       	mul	r25, r15
     526:	c0 01       	movw	r24, r0
     528:	11 24       	eor	r1, r1
     52a:	87 58       	subi	r24, 0x87	; 135
     52c:	9f 4f       	sbci	r25, 0xFF	; 255
     52e:	be 01       	movw	r22, r28
     530:	0e 94 53 04 	call	0x8a6	; 0x8a6 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     534:	80 91 a1 00 	lds	r24, 0x00A1
     538:	88 23       	and	r24, r24
     53a:	d9 f6       	brne	.-74     	; 0x4f2 <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     53c:	0e 94 15 09 	call	0x122a	; 0x122a <xTaskGetTickCount>
     540:	20 91 73 00 	lds	r18, 0x0073
     544:	30 91 74 00 	lds	r19, 0x0074
     548:	82 1b       	sub	r24, r18
     54a:	93 0b       	sbc	r25, r19
     54c:	90 93 76 00 	sts	0x0076, r25
     550:	80 93 75 00 	sts	0x0075, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     554:	89 e0       	ldi	r24, 0x09	; 9
     556:	f8 2e       	mov	r15, r24
     558:	53 c0       	rjmp	.+166    	; 0x600 <vCoRoutineSchedule+0x11e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     55a:	01 96       	adiw	r24, 0x01	; 1
     55c:	90 93 78 00 	sts	0x0078, r25
     560:	80 93 77 00 	sts	0x0077, r24
		xPassedTicks--;
     564:	21 50       	subi	r18, 0x01	; 1
     566:	30 40       	sbci	r19, 0x00	; 0
     568:	30 93 76 00 	sts	0x0076, r19
     56c:	20 93 75 00 	sts	0x0075, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     570:	89 2b       	or	r24, r25
     572:	09 f0       	breq	.+2      	; 0x576 <vCoRoutineSchedule+0x94>
     574:	3e c0       	rjmp	.+124    	; 0x5f2 <vCoRoutineSchedule+0x110>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     576:	20 91 9d 00 	lds	r18, 0x009D
     57a:	30 91 9e 00 	lds	r19, 0x009E
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     57e:	80 91 9f 00 	lds	r24, 0x009F
     582:	90 91 a0 00 	lds	r25, 0x00A0
     586:	90 93 9e 00 	sts	0x009E, r25
     58a:	80 93 9d 00 	sts	0x009D, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     58e:	30 93 a0 00 	sts	0x00A0, r19
     592:	20 93 9f 00 	sts	0x009F, r18
     596:	2d c0       	rjmp	.+90     	; 0x5f2 <vCoRoutineSchedule+0x110>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     598:	05 80       	ldd	r0, Z+5	; 0x05
     59a:	f6 81       	ldd	r31, Z+6	; 0x06
     59c:	e0 2d       	mov	r30, r0
     59e:	c6 81       	ldd	r28, Z+6	; 0x06
     5a0:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     5a2:	20 91 77 00 	lds	r18, 0x0077
     5a6:	30 91 78 00 	lds	r19, 0x0078
     5aa:	8a 81       	ldd	r24, Y+2	; 0x02
     5ac:	9b 81       	ldd	r25, Y+3	; 0x03
     5ae:	28 17       	cp	r18, r24
     5b0:	39 07       	cpc	r19, r25
     5b2:	30 f1       	brcs	.+76     	; 0x600 <vCoRoutineSchedule+0x11e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     5b4:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     5b6:	8e 01       	movw	r16, r28
     5b8:	0e 5f       	subi	r16, 0xFE	; 254
     5ba:	1f 4f       	sbci	r17, 0xFF	; 255
     5bc:	c8 01       	movw	r24, r16
     5be:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     5c2:	8c 89       	ldd	r24, Y+20	; 0x14
     5c4:	9d 89       	ldd	r25, Y+21	; 0x15
     5c6:	89 2b       	or	r24, r25
     5c8:	21 f0       	breq	.+8      	; 0x5d2 <vCoRoutineSchedule+0xf0>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     5ca:	ce 01       	movw	r24, r28
     5cc:	0c 96       	adiw	r24, 0x0c	; 12
     5ce:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     5d2:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     5d4:	9e 89       	ldd	r25, Y+22	; 0x16
     5d6:	80 91 72 00 	lds	r24, 0x0072
     5da:	89 17       	cp	r24, r25
     5dc:	10 f4       	brcc	.+4      	; 0x5e2 <vCoRoutineSchedule+0x100>
     5de:	90 93 72 00 	sts	0x0072, r25
     5e2:	9f 9d       	mul	r25, r15
     5e4:	c0 01       	movw	r24, r0
     5e6:	11 24       	eor	r1, r1
     5e8:	87 58       	subi	r24, 0x87	; 135
     5ea:	9f 4f       	sbci	r25, 0xFF	; 255
     5ec:	b8 01       	movw	r22, r16
     5ee:	0e 94 53 04 	call	0x8a6	; 0x8a6 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     5f2:	e0 91 9d 00 	lds	r30, 0x009D
     5f6:	f0 91 9e 00 	lds	r31, 0x009E
     5fa:	80 81       	ld	r24, Z
     5fc:	88 23       	and	r24, r24
     5fe:	61 f6       	brne	.-104    	; 0x598 <vCoRoutineSchedule+0xb6>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     600:	20 91 75 00 	lds	r18, 0x0075
     604:	30 91 76 00 	lds	r19, 0x0076
     608:	80 91 77 00 	lds	r24, 0x0077
     60c:	90 91 78 00 	lds	r25, 0x0078
     610:	21 15       	cp	r18, r1
     612:	31 05       	cpc	r19, r1
     614:	09 f0       	breq	.+2      	; 0x618 <vCoRoutineSchedule+0x136>
     616:	a1 cf       	rjmp	.-190    	; 0x55a <vCoRoutineSchedule+0x78>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     618:	90 93 74 00 	sts	0x0074, r25
     61c:	80 93 73 00 	sts	0x0073, r24
     620:	90 91 72 00 	lds	r25, 0x0072

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     624:	29 e0       	ldi	r18, 0x09	; 9
     626:	06 c0       	rjmp	.+12     	; 0x634 <vCoRoutineSchedule+0x152>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     628:	99 23       	and	r25, r25
     62a:	19 f4       	brne	.+6      	; 0x632 <vCoRoutineSchedule+0x150>
     62c:	10 92 72 00 	sts	0x0072, r1
     630:	32 c0       	rjmp	.+100    	; 0x696 <vCoRoutineSchedule+0x1b4>
     632:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     634:	92 9f       	mul	r25, r18
     636:	d0 01       	movw	r26, r0
     638:	11 24       	eor	r1, r1
     63a:	a7 58       	subi	r26, 0x87	; 135
     63c:	bf 4f       	sbci	r27, 0xFF	; 255
     63e:	8c 91       	ld	r24, X
     640:	88 23       	and	r24, r24
     642:	91 f3       	breq	.-28     	; 0x628 <vCoRoutineSchedule+0x146>
     644:	90 93 72 00 	sts	0x0072, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     648:	11 96       	adiw	r26, 0x01	; 1
     64a:	ed 91       	ld	r30, X+
     64c:	fc 91       	ld	r31, X
     64e:	12 97       	sbiw	r26, 0x02	; 2
     650:	02 80       	ldd	r0, Z+2	; 0x02
     652:	f3 81       	ldd	r31, Z+3	; 0x03
     654:	e0 2d       	mov	r30, r0
     656:	12 96       	adiw	r26, 0x02	; 2
     658:	fc 93       	st	X, r31
     65a:	ee 93       	st	-X, r30
     65c:	11 97       	sbiw	r26, 0x01	; 1
     65e:	cd 01       	movw	r24, r26
     660:	03 96       	adiw	r24, 0x03	; 3
     662:	e8 17       	cp	r30, r24
     664:	f9 07       	cpc	r31, r25
     666:	31 f4       	brne	.+12     	; 0x674 <vCoRoutineSchedule+0x192>
     668:	82 81       	ldd	r24, Z+2	; 0x02
     66a:	93 81       	ldd	r25, Z+3	; 0x03
     66c:	12 96       	adiw	r26, 0x02	; 2
     66e:	9c 93       	st	X, r25
     670:	8e 93       	st	-X, r24
     672:	11 97       	sbiw	r26, 0x01	; 1
     674:	11 96       	adiw	r26, 0x01	; 1
     676:	ed 91       	ld	r30, X+
     678:	fc 91       	ld	r31, X
     67a:	12 97       	sbiw	r26, 0x02	; 2
     67c:	06 80       	ldd	r0, Z+6	; 0x06
     67e:	f7 81       	ldd	r31, Z+7	; 0x07
     680:	e0 2d       	mov	r30, r0
     682:	f0 93 71 00 	sts	0x0071, r31
     686:	e0 93 70 00 	sts	0x0070, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     68a:	20 81       	ld	r18, Z
     68c:	31 81       	ldd	r19, Z+1	; 0x01
     68e:	cf 01       	movw	r24, r30
     690:	67 89       	ldd	r22, Z+23	; 0x17
     692:	f9 01       	movw	r30, r18
     694:	09 95       	icall

	return;
}
     696:	df 91       	pop	r29
     698:	cf 91       	pop	r28
     69a:	1f 91       	pop	r17
     69c:	0f 91       	pop	r16
     69e:	ff 90       	pop	r15
     6a0:	08 95       	ret

000006a2 <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     6a2:	0f 93       	push	r16
     6a4:	1f 93       	push	r17
     6a6:	cf 93       	push	r28
     6a8:	df 93       	push	r29
     6aa:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     6ac:	00 91 77 00 	lds	r16, 0x0077
     6b0:	10 91 78 00 	lds	r17, 0x0078
     6b4:	08 0f       	add	r16, r24
     6b6:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     6b8:	80 91 70 00 	lds	r24, 0x0070
     6bc:	90 91 71 00 	lds	r25, 0x0071
     6c0:	02 96       	adiw	r24, 0x02	; 2
     6c2:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     6c6:	e0 91 70 00 	lds	r30, 0x0070
     6ca:	f0 91 71 00 	lds	r31, 0x0071
     6ce:	13 83       	std	Z+3, r17	; 0x03
     6d0:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     6d2:	80 91 77 00 	lds	r24, 0x0077
     6d6:	90 91 78 00 	lds	r25, 0x0078
     6da:	bf 01       	movw	r22, r30
     6dc:	6e 5f       	subi	r22, 0xFE	; 254
     6de:	7f 4f       	sbci	r23, 0xFF	; 255
     6e0:	08 17       	cp	r16, r24
     6e2:	19 07       	cpc	r17, r25
     6e4:	28 f4       	brcc	.+10     	; 0x6f0 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     6e6:	80 91 9f 00 	lds	r24, 0x009F
     6ea:	90 91 a0 00 	lds	r25, 0x00A0
     6ee:	04 c0       	rjmp	.+8      	; 0x6f8 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     6f0:	80 91 9d 00 	lds	r24, 0x009D
     6f4:	90 91 9e 00 	lds	r25, 0x009E
     6f8:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <vListInsert>
	}

	if( pxEventList )
     6fc:	20 97       	sbiw	r28, 0x00	; 0
     6fe:	49 f0       	breq	.+18     	; 0x712 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     700:	60 91 70 00 	lds	r22, 0x0070
     704:	70 91 71 00 	lds	r23, 0x0071
     708:	64 5f       	subi	r22, 0xF4	; 244
     70a:	7f 4f       	sbci	r23, 0xFF	; 255
     70c:	ce 01       	movw	r24, r28
     70e:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <vListInsert>
	}
}
     712:	df 91       	pop	r29
     714:	cf 91       	pop	r28
     716:	1f 91       	pop	r17
     718:	0f 91       	pop	r16
     71a:	08 95       	ret

0000071c <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     71c:	af 92       	push	r10
     71e:	bf 92       	push	r11
     720:	cf 92       	push	r12
     722:	df 92       	push	r13
     724:	ef 92       	push	r14
     726:	ff 92       	push	r15
     728:	0f 93       	push	r16
     72a:	1f 93       	push	r17
     72c:	cf 93       	push	r28
     72e:	df 93       	push	r29
     730:	6c 01       	movw	r12, r24
     732:	b6 2e       	mov	r11, r22
     734:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     736:	8a e1       	ldi	r24, 0x1A	; 26
     738:	90 e0       	ldi	r25, 0x00	; 0
     73a:	0e 94 18 04 	call	0x830	; 0x830 <pvPortMalloc>
     73e:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
     740:	00 97       	sbiw	r24, 0x00	; 0
     742:	11 f4       	brne	.+4      	; 0x748 <xCoRoutineCreate+0x2c>
     744:	8f ef       	ldi	r24, 0xFF	; 255
     746:	59 c0       	rjmp	.+178    	; 0x7fa <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     748:	80 91 70 00 	lds	r24, 0x0070
     74c:	90 91 71 00 	lds	r25, 0x0071
     750:	89 2b       	or	r24, r25
     752:	21 f5       	brne	.+72     	; 0x79c <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     754:	d0 93 71 00 	sts	0x0071, r29
     758:	c0 93 70 00 	sts	0x0070, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     75c:	89 e7       	ldi	r24, 0x79	; 121
     75e:	90 e0       	ldi	r25, 0x00	; 0
     760:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>
     764:	82 e8       	ldi	r24, 0x82	; 130
     766:	90 e0       	ldi	r25, 0x00	; 0
     768:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     76c:	2b e8       	ldi	r18, 0x8B	; 139
     76e:	e2 2e       	mov	r14, r18
     770:	20 e0       	ldi	r18, 0x00	; 0
     772:	f2 2e       	mov	r15, r18
     774:	c7 01       	movw	r24, r14
     776:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     77a:	04 e9       	ldi	r16, 0x94	; 148
     77c:	10 e0       	ldi	r17, 0x00	; 0
     77e:	c8 01       	movw	r24, r16
     780:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     784:	81 ea       	ldi	r24, 0xA1	; 161
     786:	90 e0       	ldi	r25, 0x00	; 0
     788:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     78c:	f0 92 9e 00 	sts	0x009E, r15
     790:	e0 92 9d 00 	sts	0x009D, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     794:	10 93 a0 00 	sts	0x00A0, r17
     798:	00 93 9f 00 	sts	0x009F, r16
     79c:	eb 2c       	mov	r14, r11
     79e:	bb 20       	and	r11, r11
     7a0:	11 f0       	breq	.+4      	; 0x7a6 <xCoRoutineCreate+0x8a>
     7a2:	ee 24       	eor	r14, r14
     7a4:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     7a6:	19 8e       	std	Y+25, r1	; 0x19
     7a8:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     7aa:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     7ac:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     7ae:	fe 01       	movw	r30, r28
     7b0:	c1 92       	st	Z+, r12
     7b2:	d1 92       	st	Z+, r13
     7b4:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     7b6:	cf 01       	movw	r24, r30
     7b8:	0e 94 4f 04 	call	0x89e	; 0x89e <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     7bc:	ce 01       	movw	r24, r28
     7be:	0c 96       	adiw	r24, 0x0c	; 12
     7c0:	0e 94 4f 04 	call	0x89e	; 0x89e <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     7c4:	d9 87       	std	Y+9, r29	; 0x09
     7c6:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     7c8:	db 8b       	std	Y+19, r29	; 0x13
     7ca:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     7cc:	84 e0       	ldi	r24, 0x04	; 4
     7ce:	90 e0       	ldi	r25, 0x00	; 0
     7d0:	8e 19       	sub	r24, r14
     7d2:	91 09       	sbc	r25, r1
     7d4:	9d 87       	std	Y+13, r25	; 0x0d
     7d6:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     7d8:	9e 89       	ldd	r25, Y+22	; 0x16
     7da:	80 91 72 00 	lds	r24, 0x0072
     7de:	89 17       	cp	r24, r25
     7e0:	10 f4       	brcc	.+4      	; 0x7e6 <xCoRoutineCreate+0xca>
     7e2:	90 93 72 00 	sts	0x0072, r25
     7e6:	89 e0       	ldi	r24, 0x09	; 9
     7e8:	98 9f       	mul	r25, r24
     7ea:	c0 01       	movw	r24, r0
     7ec:	11 24       	eor	r1, r1
     7ee:	87 58       	subi	r24, 0x87	; 135
     7f0:	9f 4f       	sbci	r25, 0xFF	; 255
     7f2:	b8 01       	movw	r22, r16
     7f4:	0e 94 53 04 	call	0x8a6	; 0x8a6 <vListInsertEnd>
     7f8:	81 e0       	ldi	r24, 0x01	; 1
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}
	
	return xReturn;	
}
     7fa:	df 91       	pop	r29
     7fc:	cf 91       	pop	r28
     7fe:	1f 91       	pop	r17
     800:	0f 91       	pop	r16
     802:	ff 90       	pop	r15
     804:	ef 90       	pop	r14
     806:	df 90       	pop	r13
     808:	cf 90       	pop	r12
     80a:	bf 90       	pop	r11
     80c:	af 90       	pop	r10
     80e:	08 95       	ret

00000810 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     810:	08 95       	ret

00000812 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     812:	10 92 ab 00 	sts	0x00AB, r1
     816:	10 92 aa 00 	sts	0x00AA, r1
}
     81a:	08 95       	ret

0000081c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     81c:	2c ed       	ldi	r18, 0xDC	; 220
     81e:	35 e0       	ldi	r19, 0x05	; 5
     820:	80 91 aa 00 	lds	r24, 0x00AA
     824:	90 91 ab 00 	lds	r25, 0x00AB
     828:	28 1b       	sub	r18, r24
     82a:	39 0b       	sbc	r19, r25
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
}
     82c:	c9 01       	movw	r24, r18
     82e:	08 95       	ret

00000830 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     830:	0f 93       	push	r16
     832:	1f 93       	push	r17
     834:	cf 93       	push	r28
     836:	df 93       	push	r29
     838:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     83a:	0e 94 0f 09 	call	0x121e	; 0x121e <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     83e:	80 91 aa 00 	lds	r24, 0x00AA
     842:	90 91 ab 00 	lds	r25, 0x00AB
     846:	98 01       	movw	r18, r16
     848:	28 0f       	add	r18, r24
     84a:	39 1f       	adc	r19, r25
     84c:	45 e0       	ldi	r20, 0x05	; 5
     84e:	2c 3d       	cpi	r18, 0xDC	; 220
     850:	34 07       	cpc	r19, r20
     852:	58 f4       	brcc	.+22     	; 0x86a <__stack+0xb>
     854:	82 17       	cp	r24, r18
     856:	93 07       	cpc	r25, r19
     858:	40 f4       	brcc	.+16     	; 0x86a <__stack+0xb>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     85a:	ec 01       	movw	r28, r24
     85c:	c4 55       	subi	r28, 0x54	; 84
     85e:	df 4f       	sbci	r29, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
     860:	30 93 ab 00 	sts	0x00AB, r19
     864:	20 93 aa 00 	sts	0x00AA, r18
     868:	02 c0       	rjmp	.+4      	; 0x86e <__stack+0xf>
     86a:	c0 e0       	ldi	r28, 0x00	; 0
     86c:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
     86e:	0e 94 4c 0b 	call	0x1698	; 0x1698 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     872:	ce 01       	movw	r24, r28
     874:	df 91       	pop	r29
     876:	cf 91       	pop	r28
     878:	1f 91       	pop	r17
     87a:	0f 91       	pop	r16
     87c:	08 95       	ret

0000087e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     87e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     880:	9c 01       	movw	r18, r24
     882:	2d 5f       	subi	r18, 0xFD	; 253
     884:	3f 4f       	sbci	r19, 0xFF	; 255
     886:	32 83       	std	Z+2, r19	; 0x02
     888:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     88a:	8f ef       	ldi	r24, 0xFF	; 255
     88c:	9f ef       	ldi	r25, 0xFF	; 255
     88e:	94 83       	std	Z+4, r25	; 0x04
     890:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     892:	36 83       	std	Z+6, r19	; 0x06
     894:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     896:	30 87       	std	Z+8, r19	; 0x08
     898:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     89a:	10 82       	st	Z, r1
}
     89c:	08 95       	ret

0000089e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     89e:	fc 01       	movw	r30, r24
     8a0:	11 86       	std	Z+9, r1	; 0x09
     8a2:	10 86       	std	Z+8, r1	; 0x08
}
     8a4:	08 95       	ret

000008a6 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     8a6:	cf 93       	push	r28
     8a8:	df 93       	push	r29
     8aa:	ac 01       	movw	r20, r24
     8ac:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     8ae:	ec 01       	movw	r28, r24
     8b0:	29 81       	ldd	r18, Y+1	; 0x01
     8b2:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     8b4:	f9 01       	movw	r30, r18
     8b6:	82 81       	ldd	r24, Z+2	; 0x02
     8b8:	93 81       	ldd	r25, Z+3	; 0x03
     8ba:	13 96       	adiw	r26, 0x03	; 3
     8bc:	9c 93       	st	X, r25
     8be:	8e 93       	st	-X, r24
     8c0:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     8c2:	89 81       	ldd	r24, Y+1	; 0x01
     8c4:	9a 81       	ldd	r25, Y+2	; 0x02
     8c6:	15 96       	adiw	r26, 0x05	; 5
     8c8:	9c 93       	st	X, r25
     8ca:	8e 93       	st	-X, r24
     8cc:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     8ce:	02 80       	ldd	r0, Z+2	; 0x02
     8d0:	f3 81       	ldd	r31, Z+3	; 0x03
     8d2:	e0 2d       	mov	r30, r0
     8d4:	75 83       	std	Z+5, r23	; 0x05
     8d6:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     8d8:	e9 01       	movw	r28, r18
     8da:	7b 83       	std	Y+3, r23	; 0x03
     8dc:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     8de:	fa 01       	movw	r30, r20
     8e0:	72 83       	std	Z+2, r23	; 0x02
     8e2:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8e4:	19 96       	adiw	r26, 0x09	; 9
     8e6:	5c 93       	st	X, r21
     8e8:	4e 93       	st	-X, r20
     8ea:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     8ec:	80 81       	ld	r24, Z
     8ee:	8f 5f       	subi	r24, 0xFF	; 255
     8f0:	80 83       	st	Z, r24
}
     8f2:	df 91       	pop	r29
     8f4:	cf 91       	pop	r28
     8f6:	08 95       	ret

000008f8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     8f8:	cf 93       	push	r28
     8fa:	df 93       	push	r29
     8fc:	9c 01       	movw	r18, r24
     8fe:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     900:	48 81       	ld	r20, Y
     902:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     904:	8f ef       	ldi	r24, 0xFF	; 255
     906:	4f 3f       	cpi	r20, 0xFF	; 255
     908:	58 07       	cpc	r21, r24
     90a:	21 f4       	brne	.+8      	; 0x914 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     90c:	f9 01       	movw	r30, r18
     90e:	a7 81       	ldd	r26, Z+7	; 0x07
     910:	b0 85       	ldd	r27, Z+8	; 0x08
     912:	10 c0       	rjmp	.+32     	; 0x934 <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     914:	d9 01       	movw	r26, r18
     916:	13 96       	adiw	r26, 0x03	; 3
     918:	04 c0       	rjmp	.+8      	; 0x922 <vListInsert+0x2a>
     91a:	12 96       	adiw	r26, 0x02	; 2
     91c:	0d 90       	ld	r0, X+
     91e:	bc 91       	ld	r27, X
     920:	a0 2d       	mov	r26, r0
     922:	12 96       	adiw	r26, 0x02	; 2
     924:	ed 91       	ld	r30, X+
     926:	fc 91       	ld	r31, X
     928:	13 97       	sbiw	r26, 0x03	; 3
     92a:	80 81       	ld	r24, Z
     92c:	91 81       	ldd	r25, Z+1	; 0x01
     92e:	48 17       	cp	r20, r24
     930:	59 07       	cpc	r21, r25
     932:	98 f7       	brcc	.-26     	; 0x91a <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     934:	12 96       	adiw	r26, 0x02	; 2
     936:	ed 91       	ld	r30, X+
     938:	fc 91       	ld	r31, X
     93a:	13 97       	sbiw	r26, 0x03	; 3
     93c:	fb 83       	std	Y+3, r31	; 0x03
     93e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     940:	d5 83       	std	Z+5, r29	; 0x05
     942:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     944:	bd 83       	std	Y+5, r27	; 0x05
     946:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     948:	13 96       	adiw	r26, 0x03	; 3
     94a:	dc 93       	st	X, r29
     94c:	ce 93       	st	-X, r28
     94e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     950:	39 87       	std	Y+9, r19	; 0x09
     952:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     954:	f9 01       	movw	r30, r18
     956:	80 81       	ld	r24, Z
     958:	8f 5f       	subi	r24, 0xFF	; 255
     95a:	80 83       	st	Z, r24
}
     95c:	df 91       	pop	r29
     95e:	cf 91       	pop	r28
     960:	08 95       	ret

00000962 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     962:	cf 93       	push	r28
     964:	df 93       	push	r29
     966:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     968:	12 96       	adiw	r26, 0x02	; 2
     96a:	ed 91       	ld	r30, X+
     96c:	fc 91       	ld	r31, X
     96e:	13 97       	sbiw	r26, 0x03	; 3
     970:	14 96       	adiw	r26, 0x04	; 4
     972:	8d 91       	ld	r24, X+
     974:	9c 91       	ld	r25, X
     976:	15 97       	sbiw	r26, 0x05	; 5
     978:	95 83       	std	Z+5, r25	; 0x05
     97a:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     97c:	14 96       	adiw	r26, 0x04	; 4
     97e:	cd 91       	ld	r28, X+
     980:	dc 91       	ld	r29, X
     982:	15 97       	sbiw	r26, 0x05	; 5
     984:	fb 83       	std	Y+3, r31	; 0x03
     986:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     988:	18 96       	adiw	r26, 0x08	; 8
     98a:	ed 91       	ld	r30, X+
     98c:	fc 91       	ld	r31, X
     98e:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     990:	81 81       	ldd	r24, Z+1	; 0x01
     992:	92 81       	ldd	r25, Z+2	; 0x02
     994:	8a 17       	cp	r24, r26
     996:	9b 07       	cpc	r25, r27
     998:	11 f4       	brne	.+4      	; 0x99e <vListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     99a:	d2 83       	std	Z+2, r29	; 0x02
     99c:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     99e:	19 96       	adiw	r26, 0x09	; 9
     9a0:	1c 92       	st	X, r1
     9a2:	1e 92       	st	-X, r1
     9a4:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
     9a6:	80 81       	ld	r24, Z
     9a8:	81 50       	subi	r24, 0x01	; 1
     9aa:	80 83       	st	Z, r24
}
     9ac:	df 91       	pop	r29
     9ae:	cf 91       	pop	r28
     9b0:	08 95       	ret

000009b2 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
     9b2:	fc 01       	movw	r30, r24
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     9b4:	91 e1       	ldi	r25, 0x11	; 17
     9b6:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     9b8:	22 e2       	ldi	r18, 0x22	; 34
     9ba:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     9bc:	83 e3       	ldi	r24, 0x33	; 51
     9be:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     9c0:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     9c2:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     9c4:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     9c6:	80 e8       	ldi	r24, 0x80	; 128
     9c8:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     9ca:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     9cc:	82 e0       	ldi	r24, 0x02	; 2
     9ce:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     9d0:	83 e0       	ldi	r24, 0x03	; 3
     9d2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     9d4:	84 e0       	ldi	r24, 0x04	; 4
     9d6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     9d8:	85 e0       	ldi	r24, 0x05	; 5
     9da:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     9dc:	86 e0       	ldi	r24, 0x06	; 6
     9de:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     9e0:	87 e0       	ldi	r24, 0x07	; 7
     9e2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     9e4:	88 e0       	ldi	r24, 0x08	; 8
     9e6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     9e8:	89 e0       	ldi	r24, 0x09	; 9
     9ea:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     9ec:	80 e1       	ldi	r24, 0x10	; 16
     9ee:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     9f0:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     9f2:	82 e1       	ldi	r24, 0x12	; 18
     9f4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     9f6:	83 e1       	ldi	r24, 0x13	; 19
     9f8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     9fa:	84 e1       	ldi	r24, 0x14	; 20
     9fc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     9fe:	85 e1       	ldi	r24, 0x15	; 21
     a00:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     a02:	86 e1       	ldi	r24, 0x16	; 22
     a04:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     a06:	87 e1       	ldi	r24, 0x17	; 23
     a08:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     a0a:	88 e1       	ldi	r24, 0x18	; 24
     a0c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     a0e:	89 e1       	ldi	r24, 0x19	; 25
     a10:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     a12:	80 e2       	ldi	r24, 0x20	; 32
     a14:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     a16:	81 e2       	ldi	r24, 0x21	; 33
     a18:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     a1a:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     a1c:	83 e2       	ldi	r24, 0x23	; 35
     a1e:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     a20:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     a22:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     a24:	86 e2       	ldi	r24, 0x26	; 38
     a26:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     a28:	87 e2       	ldi	r24, 0x27	; 39
     a2a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     a2c:	88 e2       	ldi	r24, 0x28	; 40
     a2e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     a30:	89 e2       	ldi	r24, 0x29	; 41
     a32:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     a34:	80 e3       	ldi	r24, 0x30	; 48
     a36:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     a38:	81 e3       	ldi	r24, 0x31	; 49
     a3a:	82 93       	st	-Z, r24
     a3c:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     a3e:	cf 01       	movw	r24, r30
     a40:	08 95       	ret

00000a42 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
     a42:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
     a44:	8c e7       	ldi	r24, 0x7C	; 124
     a46:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     a48:	8b e0       	ldi	r24, 0x0B	; 11
     a4a:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     a4c:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     a4e:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     a50:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     a52:	a0 91 88 06 	lds	r26, 0x0688
     a56:	b0 91 89 06 	lds	r27, 0x0689
     a5a:	cd 91       	ld	r28, X+
     a5c:	cd bf       	out	0x3d, r28	; 61
     a5e:	dd 91       	ld	r29, X+
     a60:	de bf       	out	0x3e, r29	; 62
     a62:	ff 91       	pop	r31
     a64:	ef 91       	pop	r30
     a66:	df 91       	pop	r29
     a68:	cf 91       	pop	r28
     a6a:	bf 91       	pop	r27
     a6c:	af 91       	pop	r26
     a6e:	9f 91       	pop	r25
     a70:	8f 91       	pop	r24
     a72:	7f 91       	pop	r23
     a74:	6f 91       	pop	r22
     a76:	5f 91       	pop	r21
     a78:	4f 91       	pop	r20
     a7a:	3f 91       	pop	r19
     a7c:	2f 91       	pop	r18
     a7e:	1f 91       	pop	r17
     a80:	0f 91       	pop	r16
     a82:	ff 90       	pop	r15
     a84:	ef 90       	pop	r14
     a86:	df 90       	pop	r13
     a88:	cf 90       	pop	r12
     a8a:	bf 90       	pop	r11
     a8c:	af 90       	pop	r10
     a8e:	9f 90       	pop	r9
     a90:	8f 90       	pop	r8
     a92:	7f 90       	pop	r7
     a94:	6f 90       	pop	r6
     a96:	5f 90       	pop	r5
     a98:	4f 90       	pop	r4
     a9a:	3f 90       	pop	r3
     a9c:	2f 90       	pop	r2
     a9e:	1f 90       	pop	r1
     aa0:	0f 90       	pop	r0
     aa2:	0f be       	out	0x3f, r0	; 63
     aa4:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     aa6:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     aa8:	81 e0       	ldi	r24, 0x01	; 1
     aaa:	08 95       	ret

00000aac <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     aac:	08 95       	ret

00000aae <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     aae:	0f 92       	push	r0
     ab0:	0f b6       	in	r0, 0x3f	; 63
     ab2:	f8 94       	cli
     ab4:	0f 92       	push	r0
     ab6:	1f 92       	push	r1
     ab8:	11 24       	eor	r1, r1
     aba:	2f 92       	push	r2
     abc:	3f 92       	push	r3
     abe:	4f 92       	push	r4
     ac0:	5f 92       	push	r5
     ac2:	6f 92       	push	r6
     ac4:	7f 92       	push	r7
     ac6:	8f 92       	push	r8
     ac8:	9f 92       	push	r9
     aca:	af 92       	push	r10
     acc:	bf 92       	push	r11
     ace:	cf 92       	push	r12
     ad0:	df 92       	push	r13
     ad2:	ef 92       	push	r14
     ad4:	ff 92       	push	r15
     ad6:	0f 93       	push	r16
     ad8:	1f 93       	push	r17
     ada:	2f 93       	push	r18
     adc:	3f 93       	push	r19
     ade:	4f 93       	push	r20
     ae0:	5f 93       	push	r21
     ae2:	6f 93       	push	r22
     ae4:	7f 93       	push	r23
     ae6:	8f 93       	push	r24
     ae8:	9f 93       	push	r25
     aea:	af 93       	push	r26
     aec:	bf 93       	push	r27
     aee:	cf 93       	push	r28
     af0:	df 93       	push	r29
     af2:	ef 93       	push	r30
     af4:	ff 93       	push	r31
     af6:	a0 91 88 06 	lds	r26, 0x0688
     afa:	b0 91 89 06 	lds	r27, 0x0689
     afe:	0d b6       	in	r0, 0x3d	; 61
     b00:	0d 92       	st	X+, r0
     b02:	0e b6       	in	r0, 0x3e	; 62
     b04:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     b06:	0e 94 f7 09 	call	0x13ee	; 0x13ee <vTaskIncrementTick>
	vTaskSwitchContext();
     b0a:	0e 94 29 09 	call	0x1252	; 0x1252 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     b0e:	a0 91 88 06 	lds	r26, 0x0688
     b12:	b0 91 89 06 	lds	r27, 0x0689
     b16:	cd 91       	ld	r28, X+
     b18:	cd bf       	out	0x3d, r28	; 61
     b1a:	dd 91       	ld	r29, X+
     b1c:	de bf       	out	0x3e, r29	; 62
     b1e:	ff 91       	pop	r31
     b20:	ef 91       	pop	r30
     b22:	df 91       	pop	r29
     b24:	cf 91       	pop	r28
     b26:	bf 91       	pop	r27
     b28:	af 91       	pop	r26
     b2a:	9f 91       	pop	r25
     b2c:	8f 91       	pop	r24
     b2e:	7f 91       	pop	r23
     b30:	6f 91       	pop	r22
     b32:	5f 91       	pop	r21
     b34:	4f 91       	pop	r20
     b36:	3f 91       	pop	r19
     b38:	2f 91       	pop	r18
     b3a:	1f 91       	pop	r17
     b3c:	0f 91       	pop	r16
     b3e:	ff 90       	pop	r15
     b40:	ef 90       	pop	r14
     b42:	df 90       	pop	r13
     b44:	cf 90       	pop	r12
     b46:	bf 90       	pop	r11
     b48:	af 90       	pop	r10
     b4a:	9f 90       	pop	r9
     b4c:	8f 90       	pop	r8
     b4e:	7f 90       	pop	r7
     b50:	6f 90       	pop	r6
     b52:	5f 90       	pop	r5
     b54:	4f 90       	pop	r4
     b56:	3f 90       	pop	r3
     b58:	2f 90       	pop	r2
     b5a:	1f 90       	pop	r1
     b5c:	0f 90       	pop	r0
     b5e:	0f be       	out	0x3f, r0	; 63
     b60:	0f 90       	pop	r0

	asm volatile ( "ret" );
     b62:	08 95       	ret

00000b64 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
     b64:	0e 94 57 05 	call	0xaae	; 0xaae <vPortYieldFromTick>
		asm volatile ( "reti" );
     b68:	18 95       	reti

00000b6a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     b6a:	0f 92       	push	r0
     b6c:	0f b6       	in	r0, 0x3f	; 63
     b6e:	f8 94       	cli
     b70:	0f 92       	push	r0
     b72:	1f 92       	push	r1
     b74:	11 24       	eor	r1, r1
     b76:	2f 92       	push	r2
     b78:	3f 92       	push	r3
     b7a:	4f 92       	push	r4
     b7c:	5f 92       	push	r5
     b7e:	6f 92       	push	r6
     b80:	7f 92       	push	r7
     b82:	8f 92       	push	r8
     b84:	9f 92       	push	r9
     b86:	af 92       	push	r10
     b88:	bf 92       	push	r11
     b8a:	cf 92       	push	r12
     b8c:	df 92       	push	r13
     b8e:	ef 92       	push	r14
     b90:	ff 92       	push	r15
     b92:	0f 93       	push	r16
     b94:	1f 93       	push	r17
     b96:	2f 93       	push	r18
     b98:	3f 93       	push	r19
     b9a:	4f 93       	push	r20
     b9c:	5f 93       	push	r21
     b9e:	6f 93       	push	r22
     ba0:	7f 93       	push	r23
     ba2:	8f 93       	push	r24
     ba4:	9f 93       	push	r25
     ba6:	af 93       	push	r26
     ba8:	bf 93       	push	r27
     baa:	cf 93       	push	r28
     bac:	df 93       	push	r29
     bae:	ef 93       	push	r30
     bb0:	ff 93       	push	r31
     bb2:	a0 91 88 06 	lds	r26, 0x0688
     bb6:	b0 91 89 06 	lds	r27, 0x0689
     bba:	0d b6       	in	r0, 0x3d	; 61
     bbc:	0d 92       	st	X+, r0
     bbe:	0e b6       	in	r0, 0x3e	; 62
     bc0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     bc2:	0e 94 29 09 	call	0x1252	; 0x1252 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     bc6:	a0 91 88 06 	lds	r26, 0x0688
     bca:	b0 91 89 06 	lds	r27, 0x0689
     bce:	cd 91       	ld	r28, X+
     bd0:	cd bf       	out	0x3d, r28	; 61
     bd2:	dd 91       	ld	r29, X+
     bd4:	de bf       	out	0x3e, r29	; 62
     bd6:	ff 91       	pop	r31
     bd8:	ef 91       	pop	r30
     bda:	df 91       	pop	r29
     bdc:	cf 91       	pop	r28
     bde:	bf 91       	pop	r27
     be0:	af 91       	pop	r26
     be2:	9f 91       	pop	r25
     be4:	8f 91       	pop	r24
     be6:	7f 91       	pop	r23
     be8:	6f 91       	pop	r22
     bea:	5f 91       	pop	r21
     bec:	4f 91       	pop	r20
     bee:	3f 91       	pop	r19
     bf0:	2f 91       	pop	r18
     bf2:	1f 91       	pop	r17
     bf4:	0f 91       	pop	r16
     bf6:	ff 90       	pop	r15
     bf8:	ef 90       	pop	r14
     bfa:	df 90       	pop	r13
     bfc:	cf 90       	pop	r12
     bfe:	bf 90       	pop	r11
     c00:	af 90       	pop	r10
     c02:	9f 90       	pop	r9
     c04:	8f 90       	pop	r8
     c06:	7f 90       	pop	r7
     c08:	6f 90       	pop	r6
     c0a:	5f 90       	pop	r5
     c0c:	4f 90       	pop	r4
     c0e:	3f 90       	pop	r3
     c10:	2f 90       	pop	r2
     c12:	1f 90       	pop	r1
     c14:	0f 90       	pop	r0
     c16:	0f be       	out	0x3f, r0	; 63
     c18:	0f 90       	pop	r0

	asm volatile ( "ret" );
     c1a:	08 95       	ret

00000c1c <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
     c1c:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     c1e:	0f b6       	in	r0, 0x3f	; 63
     c20:	f8 94       	cli
     c22:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
     c24:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     c26:	0f 90       	pop	r0
     c28:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     c2a:	08 95       	ret

00000c2c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
     c2c:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
     c2e:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
     c30:	08 95       	ret

00000c32 <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
     c32:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     c34:	82 8d       	ldd	r24, Z+26	; 0x1a
     c36:	90 e0       	ldi	r25, 0x00	; 0
     c38:	88 23       	and	r24, r24
     c3a:	09 f4       	brne	.+2      	; 0xc3e <xQueueIsQueueEmptyFromISR+0xc>
     c3c:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
     c3e:	89 2f       	mov	r24, r25
     c40:	08 95       	ret

00000c42 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
     c42:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     c44:	92 8d       	ldd	r25, Z+26	; 0x1a
     c46:	20 e0       	ldi	r18, 0x00	; 0
     c48:	83 8d       	ldd	r24, Z+27	; 0x1b
     c4a:	98 17       	cp	r25, r24
     c4c:	09 f4       	brne	.+2      	; 0xc50 <xQueueIsQueueFullFromISR+0xe>
     c4e:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
     c50:	82 2f       	mov	r24, r18
     c52:	08 95       	ret

00000c54 <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
     c54:	0f 93       	push	r16
     c56:	1f 93       	push	r17
     c58:	8c 01       	movw	r16, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
     c5a:	fc 01       	movw	r30, r24
     c5c:	80 81       	ld	r24, Z
     c5e:	91 81       	ldd	r25, Z+1	; 0x01
     c60:	0e 94 08 04 	call	0x810	; 0x810 <vPortFree>
	vPortFree( pxQueue );
     c64:	c8 01       	movw	r24, r16
     c66:	0e 94 08 04 	call	0x810	; 0x810 <vPortFree>
}
     c6a:	1f 91       	pop	r17
     c6c:	0f 91       	pop	r16
     c6e:	08 95       	ret

00000c70 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
     c70:	0f 93       	push	r16
     c72:	1f 93       	push	r17
     c74:	cf 93       	push	r28
     c76:	df 93       	push	r29
     c78:	ec 01       	movw	r28, r24
     c7a:	fb 01       	movw	r30, r22
     c7c:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     c7e:	8a 8d       	ldd	r24, Y+26	; 0x1a
     c80:	88 23       	and	r24, r24
     c82:	81 f1       	breq	.+96     	; 0xce4 <xQueueReceiveFromISR+0x74>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     c84:	48 81       	ld	r20, Y
     c86:	59 81       	ldd	r21, Y+1	; 0x01
     c88:	41 15       	cp	r20, r1
     c8a:	51 05       	cpc	r21, r1
     c8c:	a9 f0       	breq	.+42     	; 0xcb8 <xQueueReceiveFromISR+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     c8e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     c90:	2e 81       	ldd	r18, Y+6	; 0x06
     c92:	3f 81       	ldd	r19, Y+7	; 0x07
     c94:	28 0f       	add	r18, r24
     c96:	31 1d       	adc	r19, r1
     c98:	3f 83       	std	Y+7, r19	; 0x07
     c9a:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     c9c:	8a 81       	ldd	r24, Y+2	; 0x02
     c9e:	9b 81       	ldd	r25, Y+3	; 0x03
     ca0:	28 17       	cp	r18, r24
     ca2:	39 07       	cpc	r19, r25
     ca4:	10 f0       	brcs	.+4      	; 0xcaa <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     ca6:	5f 83       	std	Y+7, r21	; 0x07
     ca8:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     caa:	4c 8d       	ldd	r20, Y+28	; 0x1c
     cac:	6e 81       	ldd	r22, Y+6	; 0x06
     cae:	7f 81       	ldd	r23, Y+7	; 0x07
     cb0:	cf 01       	movw	r24, r30
     cb2:	50 e0       	ldi	r21, 0x00	; 0
     cb4:	0e 94 9f 10 	call	0x213e	; 0x213e <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
     cb8:	8a 8d       	ldd	r24, Y+26	; 0x1a
     cba:	81 50       	subi	r24, 0x01	; 1
     cbc:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
     cbe:	8d 8d       	ldd	r24, Y+29	; 0x1d
     cc0:	8f 3f       	cpi	r24, 0xFF	; 255
     cc2:	69 f4       	brne	.+26     	; 0xcde <xQueueReceiveFromISR+0x6e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     cc4:	88 85       	ldd	r24, Y+8	; 0x08
     cc6:	88 23       	and	r24, r24
     cc8:	61 f0       	breq	.+24     	; 0xce2 <xQueueReceiveFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     cca:	ce 01       	movw	r24, r28
     ccc:	08 96       	adiw	r24, 0x08	; 8
     cce:	0e 94 b8 09 	call	0x1370	; 0x1370 <xTaskRemoveFromEventList>
     cd2:	88 23       	and	r24, r24
     cd4:	31 f0       	breq	.+12     	; 0xce2 <xQueueReceiveFromISR+0x72>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
     cd6:	81 e0       	ldi	r24, 0x01	; 1
     cd8:	f8 01       	movw	r30, r16
     cda:	80 83       	st	Z, r24
     cdc:	03 c0       	rjmp	.+6      	; 0xce4 <xQueueReceiveFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
     cde:	8f 5f       	subi	r24, 0xFF	; 255
     ce0:	8d 8f       	std	Y+29, r24	; 0x1d
     ce2:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     ce4:	df 91       	pop	r29
     ce6:	cf 91       	pop	r28
     ce8:	1f 91       	pop	r17
     cea:	0f 91       	pop	r16
     cec:	08 95       	ret

00000cee <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     cee:	cf 93       	push	r28
     cf0:	df 93       	push	r29
     cf2:	ec 01       	movw	r28, r24
     cf4:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     cf6:	4c 8d       	ldd	r20, Y+28	; 0x1c
     cf8:	44 23       	and	r20, r20
     cfa:	a1 f1       	breq	.+104    	; 0xd64 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     cfc:	88 23       	and	r24, r24
     cfe:	b1 f4       	brne	.+44     	; 0xd2c <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     d00:	8c 81       	ldd	r24, Y+4	; 0x04
     d02:	9d 81       	ldd	r25, Y+5	; 0x05
     d04:	50 e0       	ldi	r21, 0x00	; 0
     d06:	0e 94 9f 10 	call	0x213e	; 0x213e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     d0a:	8c 8d       	ldd	r24, Y+28	; 0x1c
     d0c:	2c 81       	ldd	r18, Y+4	; 0x04
     d0e:	3d 81       	ldd	r19, Y+5	; 0x05
     d10:	28 0f       	add	r18, r24
     d12:	31 1d       	adc	r19, r1
     d14:	3d 83       	std	Y+5, r19	; 0x05
     d16:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     d18:	8a 81       	ldd	r24, Y+2	; 0x02
     d1a:	9b 81       	ldd	r25, Y+3	; 0x03
     d1c:	28 17       	cp	r18, r24
     d1e:	39 07       	cpc	r19, r25
     d20:	08 f1       	brcs	.+66     	; 0xd64 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     d22:	88 81       	ld	r24, Y
     d24:	99 81       	ldd	r25, Y+1	; 0x01
     d26:	9d 83       	std	Y+5, r25	; 0x05
     d28:	8c 83       	std	Y+4, r24	; 0x04
     d2a:	1c c0       	rjmp	.+56     	; 0xd64 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     d2c:	8e 81       	ldd	r24, Y+6	; 0x06
     d2e:	9f 81       	ldd	r25, Y+7	; 0x07
     d30:	50 e0       	ldi	r21, 0x00	; 0
     d32:	0e 94 9f 10 	call	0x213e	; 0x213e <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     d36:	8c 8d       	ldd	r24, Y+28	; 0x1c
     d38:	90 e0       	ldi	r25, 0x00	; 0
     d3a:	44 27       	eor	r20, r20
     d3c:	55 27       	eor	r21, r21
     d3e:	48 1b       	sub	r20, r24
     d40:	59 0b       	sbc	r21, r25
     d42:	8e 81       	ldd	r24, Y+6	; 0x06
     d44:	9f 81       	ldd	r25, Y+7	; 0x07
     d46:	84 0f       	add	r24, r20
     d48:	95 1f       	adc	r25, r21
     d4a:	9f 83       	std	Y+7, r25	; 0x07
     d4c:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     d4e:	28 81       	ld	r18, Y
     d50:	39 81       	ldd	r19, Y+1	; 0x01
     d52:	82 17       	cp	r24, r18
     d54:	93 07       	cpc	r25, r19
     d56:	30 f4       	brcc	.+12     	; 0xd64 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     d58:	8a 81       	ldd	r24, Y+2	; 0x02
     d5a:	9b 81       	ldd	r25, Y+3	; 0x03
     d5c:	84 0f       	add	r24, r20
     d5e:	95 1f       	adc	r25, r21
     d60:	9f 83       	std	Y+7, r25	; 0x07
     d62:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     d64:	8a 8d       	ldd	r24, Y+26	; 0x1a
     d66:	8f 5f       	subi	r24, 0xFF	; 255
     d68:	8a 8f       	std	Y+26, r24	; 0x1a
}
     d6a:	df 91       	pop	r29
     d6c:	cf 91       	pop	r28
     d6e:	08 95       	ret

00000d70 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     d70:	0f 93       	push	r16
     d72:	1f 93       	push	r17
     d74:	cf 93       	push	r28
     d76:	df 93       	push	r29
     d78:	ec 01       	movw	r28, r24
     d7a:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     d7c:	9a 8d       	ldd	r25, Y+26	; 0x1a
     d7e:	8b 8d       	ldd	r24, Y+27	; 0x1b
     d80:	98 17       	cp	r25, r24
     d82:	10 f0       	brcs	.+4      	; 0xd88 <xQueueGenericSendFromISR+0x18>
     d84:	80 e0       	ldi	r24, 0x00	; 0
     d86:	17 c0       	rjmp	.+46     	; 0xdb6 <xQueueGenericSendFromISR+0x46>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     d88:	ce 01       	movw	r24, r28
     d8a:	42 2f       	mov	r20, r18
     d8c:	0e 94 77 06 	call	0xcee	; 0xcee <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     d90:	8e 8d       	ldd	r24, Y+30	; 0x1e
     d92:	8f 3f       	cpi	r24, 0xFF	; 255
     d94:	69 f4       	brne	.+26     	; 0xdb0 <xQueueGenericSendFromISR+0x40>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d96:	89 89       	ldd	r24, Y+17	; 0x11
     d98:	88 23       	and	r24, r24
     d9a:	61 f0       	breq	.+24     	; 0xdb4 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     d9c:	ce 01       	movw	r24, r28
     d9e:	41 96       	adiw	r24, 0x11	; 17
     da0:	0e 94 b8 09 	call	0x1370	; 0x1370 <xTaskRemoveFromEventList>
     da4:	88 23       	and	r24, r24
     da6:	31 f0       	breq	.+12     	; 0xdb4 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
     da8:	81 e0       	ldi	r24, 0x01	; 1
     daa:	f8 01       	movw	r30, r16
     dac:	80 83       	st	Z, r24
     dae:	03 c0       	rjmp	.+6      	; 0xdb6 <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     db0:	8f 5f       	subi	r24, 0xFF	; 255
     db2:	8e 8f       	std	Y+30, r24	; 0x1e
     db4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     db6:	df 91       	pop	r29
     db8:	cf 91       	pop	r28
     dba:	1f 91       	pop	r17
     dbc:	0f 91       	pop	r16
     dbe:	08 95       	ret

00000dc0 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     dc0:	0f 93       	push	r16
     dc2:	1f 93       	push	r17
     dc4:	cf 93       	push	r28
     dc6:	df 93       	push	r29
     dc8:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     dca:	0f b6       	in	r0, 0x3f	; 63
     dcc:	f8 94       	cli
     dce:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     dd0:	8c 01       	movw	r16, r24
     dd2:	0f 5e       	subi	r16, 0xEF	; 239
     dd4:	1f 4f       	sbci	r17, 0xFF	; 255
     dd6:	0d c0       	rjmp	.+26     	; 0xdf2 <prvUnlockQueue+0x32>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     dd8:	89 89       	ldd	r24, Y+17	; 0x11
     dda:	88 23       	and	r24, r24
     ddc:	69 f0       	breq	.+26     	; 0xdf8 <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     dde:	c8 01       	movw	r24, r16
     de0:	0e 94 b8 09 	call	0x1370	; 0x1370 <xTaskRemoveFromEventList>
     de4:	88 23       	and	r24, r24
     de6:	11 f0       	breq	.+4      	; 0xdec <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     de8:	0e 94 b4 09 	call	0x1368	; 0x1368 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     dec:	8e 8d       	ldd	r24, Y+30	; 0x1e
     dee:	81 50       	subi	r24, 0x01	; 1
     df0:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     df2:	8e 8d       	ldd	r24, Y+30	; 0x1e
     df4:	18 16       	cp	r1, r24
     df6:	84 f3       	brlt	.-32     	; 0xdd8 <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     df8:	8f ef       	ldi	r24, 0xFF	; 255
     dfa:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     dfc:	0f 90       	pop	r0
     dfe:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     e00:	0f b6       	in	r0, 0x3f	; 63
     e02:	f8 94       	cli
     e04:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     e06:	8e 01       	movw	r16, r28
     e08:	08 5f       	subi	r16, 0xF8	; 248
     e0a:	1f 4f       	sbci	r17, 0xFF	; 255
     e0c:	0d c0       	rjmp	.+26     	; 0xe28 <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     e0e:	88 85       	ldd	r24, Y+8	; 0x08
     e10:	88 23       	and	r24, r24
     e12:	69 f0       	breq	.+26     	; 0xe2e <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     e14:	c8 01       	movw	r24, r16
     e16:	0e 94 b8 09 	call	0x1370	; 0x1370 <xTaskRemoveFromEventList>
     e1a:	88 23       	and	r24, r24
     e1c:	11 f0       	breq	.+4      	; 0xe22 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
     e1e:	0e 94 b4 09 	call	0x1368	; 0x1368 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     e22:	8d 8d       	ldd	r24, Y+29	; 0x1d
     e24:	81 50       	subi	r24, 0x01	; 1
     e26:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     e28:	8d 8d       	ldd	r24, Y+29	; 0x1d
     e2a:	18 16       	cp	r1, r24
     e2c:	84 f3       	brlt	.-32     	; 0xe0e <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     e2e:	8f ef       	ldi	r24, 0xFF	; 255
     e30:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     e32:	0f 90       	pop	r0
     e34:	0f be       	out	0x3f, r0	; 63
}
     e36:	df 91       	pop	r29
     e38:	cf 91       	pop	r28
     e3a:	1f 91       	pop	r17
     e3c:	0f 91       	pop	r16
     e3e:	08 95       	ret

00000e40 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     e40:	7f 92       	push	r7
     e42:	8f 92       	push	r8
     e44:	9f 92       	push	r9
     e46:	af 92       	push	r10
     e48:	bf 92       	push	r11
     e4a:	cf 92       	push	r12
     e4c:	df 92       	push	r13
     e4e:	ef 92       	push	r14
     e50:	ff 92       	push	r15
     e52:	0f 93       	push	r16
     e54:	1f 93       	push	r17
     e56:	df 93       	push	r29
     e58:	cf 93       	push	r28
     e5a:	00 d0       	rcall	.+0      	; 0xe5c <xQueueGenericReceive+0x1c>
     e5c:	00 d0       	rcall	.+0      	; 0xe5e <xQueueGenericReceive+0x1e>
     e5e:	0f 92       	push	r0
     e60:	cd b7       	in	r28, 0x3d	; 61
     e62:	de b7       	in	r29, 0x3e	; 62
     e64:	8c 01       	movw	r16, r24
     e66:	96 2e       	mov	r9, r22
     e68:	87 2e       	mov	r8, r23
     e6a:	5d 83       	std	Y+5, r21	; 0x05
     e6c:	4c 83       	std	Y+4, r20	; 0x04
     e6e:	72 2e       	mov	r7, r18
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     e70:	91 e1       	ldi	r25, 0x11	; 17
     e72:	c9 2e       	mov	r12, r25
     e74:	d1 2c       	mov	r13, r1
     e76:	c0 0e       	add	r12, r16
     e78:	d1 1e       	adc	r13, r17
     e7a:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     e7c:	7e 01       	movw	r14, r28
     e7e:	08 94       	sec
     e80:	e1 1c       	adc	r14, r1
     e82:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     e84:	84 e0       	ldi	r24, 0x04	; 4
     e86:	a8 2e       	mov	r10, r24
     e88:	b1 2c       	mov	r11, r1
     e8a:	ac 0e       	add	r10, r28
     e8c:	bd 1e       	adc	r11, r29
     e8e:	01 c0       	rjmp	.+2      	; 0xe92 <xQueueGenericReceive+0x52>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     e90:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     e92:	0f b6       	in	r0, 0x3f	; 63
     e94:	f8 94       	cli
     e96:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     e98:	f8 01       	movw	r30, r16
     e9a:	82 8d       	ldd	r24, Z+26	; 0x1a
     e9c:	88 23       	and	r24, r24
     e9e:	09 f4       	brne	.+2      	; 0xea2 <xQueueGenericReceive+0x62>
     ea0:	3e c0       	rjmp	.+124    	; 0xf1e <xQueueGenericReceive+0xde>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     ea2:	e6 80       	ldd	r14, Z+6	; 0x06
     ea4:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     ea6:	40 81       	ld	r20, Z
     ea8:	51 81       	ldd	r21, Z+1	; 0x01
     eaa:	41 15       	cp	r20, r1
     eac:	51 05       	cpc	r21, r1
     eae:	b1 f0       	breq	.+44     	; 0xedc <xQueueGenericReceive+0x9c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     eb0:	84 8d       	ldd	r24, Z+28	; 0x1c
     eb2:	97 01       	movw	r18, r14
     eb4:	28 0f       	add	r18, r24
     eb6:	31 1d       	adc	r19, r1
     eb8:	37 83       	std	Z+7, r19	; 0x07
     eba:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     ebc:	82 81       	ldd	r24, Z+2	; 0x02
     ebe:	93 81       	ldd	r25, Z+3	; 0x03
     ec0:	28 17       	cp	r18, r24
     ec2:	39 07       	cpc	r19, r25
     ec4:	10 f0       	brcs	.+4      	; 0xeca <xQueueGenericReceive+0x8a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     ec6:	57 83       	std	Z+7, r21	; 0x07
     ec8:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     eca:	f8 01       	movw	r30, r16
     ecc:	44 8d       	ldd	r20, Z+28	; 0x1c
     ece:	66 81       	ldd	r22, Z+6	; 0x06
     ed0:	77 81       	ldd	r23, Z+7	; 0x07
     ed2:	89 2d       	mov	r24, r9
     ed4:	98 2d       	mov	r25, r8
     ed6:	50 e0       	ldi	r21, 0x00	; 0
     ed8:	0e 94 9f 10 	call	0x213e	; 0x213e <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
     edc:	77 20       	and	r7, r7
     ede:	71 f4       	brne	.+28     	; 0xefc <xQueueGenericReceive+0xbc>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     ee0:	f8 01       	movw	r30, r16
     ee2:	82 8d       	ldd	r24, Z+26	; 0x1a
     ee4:	81 50       	subi	r24, 0x01	; 1
     ee6:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ee8:	80 85       	ldd	r24, Z+8	; 0x08
     eea:	88 23       	and	r24, r24
     eec:	a1 f0       	breq	.+40     	; 0xf16 <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     eee:	c8 01       	movw	r24, r16
     ef0:	08 96       	adiw	r24, 0x08	; 8
     ef2:	0e 94 b8 09 	call	0x1370	; 0x1370 <xTaskRemoveFromEventList>
     ef6:	81 30       	cpi	r24, 0x01	; 1
     ef8:	71 f4       	brne	.+28     	; 0xf16 <xQueueGenericReceive+0xd6>
     efa:	0b c0       	rjmp	.+22     	; 0xf12 <xQueueGenericReceive+0xd2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     efc:	f8 01       	movw	r30, r16
     efe:	f7 82       	std	Z+7, r15	; 0x07
     f00:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f02:	81 89       	ldd	r24, Z+17	; 0x11
     f04:	88 23       	and	r24, r24
     f06:	39 f0       	breq	.+14     	; 0xf16 <xQueueGenericReceive+0xd6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     f08:	c6 01       	movw	r24, r12
     f0a:	0e 94 b8 09 	call	0x1370	; 0x1370 <xTaskRemoveFromEventList>
     f0e:	88 23       	and	r24, r24
     f10:	11 f0       	breq	.+4      	; 0xf16 <xQueueGenericReceive+0xd6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     f12:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     f16:	0f 90       	pop	r0
     f18:	0f be       	out	0x3f, r0	; 63
     f1a:	81 e0       	ldi	r24, 0x01	; 1
     f1c:	4a c0       	rjmp	.+148    	; 0xfb2 <xQueueGenericReceive+0x172>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     f1e:	8c 81       	ldd	r24, Y+4	; 0x04
     f20:	9d 81       	ldd	r25, Y+5	; 0x05
     f22:	89 2b       	or	r24, r25
     f24:	19 f4       	brne	.+6      	; 0xf2c <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     f26:	0f 90       	pop	r0
     f28:	0f be       	out	0x3f, r0	; 63
     f2a:	42 c0       	rjmp	.+132    	; 0xfb0 <xQueueGenericReceive+0x170>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
     f2c:	22 23       	and	r18, r18
     f2e:	19 f4       	brne	.+6      	; 0xf36 <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     f30:	c7 01       	movw	r24, r14
     f32:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
     f36:	0f 90       	pop	r0
     f38:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     f3a:	0e 94 0f 09 	call	0x121e	; 0x121e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     f3e:	0f b6       	in	r0, 0x3f	; 63
     f40:	f8 94       	cli
     f42:	0f 92       	push	r0
     f44:	f8 01       	movw	r30, r16
     f46:	85 8d       	ldd	r24, Z+29	; 0x1d
     f48:	8f 3f       	cpi	r24, 0xFF	; 255
     f4a:	09 f4       	brne	.+2      	; 0xf4e <xQueueGenericReceive+0x10e>
     f4c:	15 8e       	std	Z+29, r1	; 0x1d
     f4e:	f8 01       	movw	r30, r16
     f50:	86 8d       	ldd	r24, Z+30	; 0x1e
     f52:	8f 3f       	cpi	r24, 0xFF	; 255
     f54:	09 f4       	brne	.+2      	; 0xf58 <xQueueGenericReceive+0x118>
     f56:	16 8e       	std	Z+30, r1	; 0x1e
     f58:	0f 90       	pop	r0
     f5a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     f5c:	c7 01       	movw	r24, r14
     f5e:	b5 01       	movw	r22, r10
     f60:	0e 94 76 09 	call	0x12ec	; 0x12ec <xTaskCheckForTimeOut>
     f64:	88 23       	and	r24, r24
     f66:	f9 f4       	brne	.+62     	; 0xfa6 <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     f68:	0f b6       	in	r0, 0x3f	; 63
     f6a:	f8 94       	cli
     f6c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     f6e:	f8 01       	movw	r30, r16
     f70:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     f72:	0f 90       	pop	r0
     f74:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     f76:	88 23       	and	r24, r24
     f78:	81 f4       	brne	.+32     	; 0xf9a <xQueueGenericReceive+0x15a>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     f7a:	6c 81       	ldd	r22, Y+4	; 0x04
     f7c:	7d 81       	ldd	r23, Y+5	; 0x05
     f7e:	c6 01       	movw	r24, r12
     f80:	0e 94 20 0b 	call	0x1640	; 0x1640 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     f84:	c8 01       	movw	r24, r16
     f86:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     f8a:	0e 94 4c 0b 	call	0x1698	; 0x1698 <xTaskResumeAll>
     f8e:	88 23       	and	r24, r24
     f90:	09 f0       	breq	.+2      	; 0xf94 <xQueueGenericReceive+0x154>
     f92:	7e cf       	rjmp	.-260    	; 0xe90 <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
     f94:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vPortYield>
     f98:	7b cf       	rjmp	.-266    	; 0xe90 <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     f9a:	c8 01       	movw	r24, r16
     f9c:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     fa0:	0e 94 4c 0b 	call	0x1698	; 0x1698 <xTaskResumeAll>
     fa4:	75 cf       	rjmp	.-278    	; 0xe90 <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     fa6:	c8 01       	movw	r24, r16
     fa8:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     fac:	0e 94 4c 0b 	call	0x1698	; 0x1698 <xTaskResumeAll>
     fb0:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
     fb2:	0f 90       	pop	r0
     fb4:	0f 90       	pop	r0
     fb6:	0f 90       	pop	r0
     fb8:	0f 90       	pop	r0
     fba:	0f 90       	pop	r0
     fbc:	cf 91       	pop	r28
     fbe:	df 91       	pop	r29
     fc0:	1f 91       	pop	r17
     fc2:	0f 91       	pop	r16
     fc4:	ff 90       	pop	r15
     fc6:	ef 90       	pop	r14
     fc8:	df 90       	pop	r13
     fca:	cf 90       	pop	r12
     fcc:	bf 90       	pop	r11
     fce:	af 90       	pop	r10
     fd0:	9f 90       	pop	r9
     fd2:	8f 90       	pop	r8
     fd4:	7f 90       	pop	r7
     fd6:	08 95       	ret

00000fd8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     fd8:	7f 92       	push	r7
     fda:	8f 92       	push	r8
     fdc:	9f 92       	push	r9
     fde:	af 92       	push	r10
     fe0:	bf 92       	push	r11
     fe2:	cf 92       	push	r12
     fe4:	df 92       	push	r13
     fe6:	ef 92       	push	r14
     fe8:	ff 92       	push	r15
     fea:	0f 93       	push	r16
     fec:	1f 93       	push	r17
     fee:	df 93       	push	r29
     ff0:	cf 93       	push	r28
     ff2:	00 d0       	rcall	.+0      	; 0xff4 <xQueueGenericSend+0x1c>
     ff4:	00 d0       	rcall	.+0      	; 0xff6 <xQueueGenericSend+0x1e>
     ff6:	0f 92       	push	r0
     ff8:	cd b7       	in	r28, 0x3d	; 61
     ffa:	de b7       	in	r29, 0x3e	; 62
     ffc:	8c 01       	movw	r16, r24
     ffe:	6b 01       	movw	r12, r22
    1000:	5d 83       	std	Y+5, r21	; 0x05
    1002:	4c 83       	std	Y+4, r20	; 0x04
    1004:	72 2e       	mov	r7, r18
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1006:	48 e0       	ldi	r20, 0x08	; 8
    1008:	e4 2e       	mov	r14, r20
    100a:	f1 2c       	mov	r15, r1
    100c:	e8 0e       	add	r14, r24
    100e:	f9 1e       	adc	r15, r25
    1010:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1012:	5e 01       	movw	r10, r28
    1014:	08 94       	sec
    1016:	a1 1c       	adc	r10, r1
    1018:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    101a:	34 e0       	ldi	r19, 0x04	; 4
    101c:	83 2e       	mov	r8, r19
    101e:	91 2c       	mov	r9, r1
    1020:	8c 0e       	add	r8, r28
    1022:	9d 1e       	adc	r9, r29
    1024:	01 c0       	rjmp	.+2      	; 0x1028 <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1026:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1028:	0f b6       	in	r0, 0x3f	; 63
    102a:	f8 94       	cli
    102c:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    102e:	f8 01       	movw	r30, r16
    1030:	92 8d       	ldd	r25, Z+26	; 0x1a
    1032:	83 8d       	ldd	r24, Z+27	; 0x1b
    1034:	98 17       	cp	r25, r24
    1036:	a8 f4       	brcc	.+42     	; 0x1062 <xQueueGenericSend+0x8a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1038:	c8 01       	movw	r24, r16
    103a:	b6 01       	movw	r22, r12
    103c:	47 2d       	mov	r20, r7
    103e:	0e 94 77 06 	call	0xcee	; 0xcee <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1042:	f8 01       	movw	r30, r16
    1044:	81 89       	ldd	r24, Z+17	; 0x11
    1046:	88 23       	and	r24, r24
    1048:	41 f0       	breq	.+16     	; 0x105a <xQueueGenericSend+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    104a:	c8 01       	movw	r24, r16
    104c:	41 96       	adiw	r24, 0x11	; 17
    104e:	0e 94 b8 09 	call	0x1370	; 0x1370 <xTaskRemoveFromEventList>
    1052:	81 30       	cpi	r24, 0x01	; 1
    1054:	11 f4       	brne	.+4      	; 0x105a <xQueueGenericSend+0x82>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1056:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    105a:	0f 90       	pop	r0
    105c:	0f be       	out	0x3f, r0	; 63
    105e:	81 e0       	ldi	r24, 0x01	; 1
    1060:	4c c0       	rjmp	.+152    	; 0x10fa <xQueueGenericSend+0x122>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1062:	8c 81       	ldd	r24, Y+4	; 0x04
    1064:	9d 81       	ldd	r25, Y+5	; 0x05
    1066:	89 2b       	or	r24, r25
    1068:	19 f4       	brne	.+6      	; 0x1070 <xQueueGenericSend+0x98>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    106a:	0f 90       	pop	r0
    106c:	0f be       	out	0x3f, r0	; 63
    106e:	44 c0       	rjmp	.+136    	; 0x10f8 <xQueueGenericSend+0x120>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    1070:	22 23       	and	r18, r18
    1072:	19 f4       	brne	.+6      	; 0x107a <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1074:	c5 01       	movw	r24, r10
    1076:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    107a:	0f 90       	pop	r0
    107c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    107e:	0e 94 0f 09 	call	0x121e	; 0x121e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1082:	0f b6       	in	r0, 0x3f	; 63
    1084:	f8 94       	cli
    1086:	0f 92       	push	r0
    1088:	f8 01       	movw	r30, r16
    108a:	85 8d       	ldd	r24, Z+29	; 0x1d
    108c:	8f 3f       	cpi	r24, 0xFF	; 255
    108e:	09 f4       	brne	.+2      	; 0x1092 <xQueueGenericSend+0xba>
    1090:	15 8e       	std	Z+29, r1	; 0x1d
    1092:	f8 01       	movw	r30, r16
    1094:	86 8d       	ldd	r24, Z+30	; 0x1e
    1096:	8f 3f       	cpi	r24, 0xFF	; 255
    1098:	09 f4       	brne	.+2      	; 0x109c <xQueueGenericSend+0xc4>
    109a:	16 8e       	std	Z+30, r1	; 0x1e
    109c:	0f 90       	pop	r0
    109e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    10a0:	c5 01       	movw	r24, r10
    10a2:	b4 01       	movw	r22, r8
    10a4:	0e 94 76 09 	call	0x12ec	; 0x12ec <xTaskCheckForTimeOut>
    10a8:	88 23       	and	r24, r24
    10aa:	09 f5       	brne	.+66     	; 0x10ee <xQueueGenericSend+0x116>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    10ac:	0f b6       	in	r0, 0x3f	; 63
    10ae:	f8 94       	cli
    10b0:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    10b2:	f8 01       	movw	r30, r16
    10b4:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    10b6:	0f 90       	pop	r0
    10b8:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    10ba:	f8 01       	movw	r30, r16
    10bc:	83 8d       	ldd	r24, Z+27	; 0x1b
    10be:	98 17       	cp	r25, r24
    10c0:	81 f4       	brne	.+32     	; 0x10e2 <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    10c2:	6c 81       	ldd	r22, Y+4	; 0x04
    10c4:	7d 81       	ldd	r23, Y+5	; 0x05
    10c6:	c7 01       	movw	r24, r14
    10c8:	0e 94 20 0b 	call	0x1640	; 0x1640 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    10cc:	c8 01       	movw	r24, r16
    10ce:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    10d2:	0e 94 4c 0b 	call	0x1698	; 0x1698 <xTaskResumeAll>
    10d6:	88 23       	and	r24, r24
    10d8:	09 f0       	breq	.+2      	; 0x10dc <xQueueGenericSend+0x104>
    10da:	a5 cf       	rjmp	.-182    	; 0x1026 <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    10dc:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vPortYield>
    10e0:	a2 cf       	rjmp	.-188    	; 0x1026 <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    10e2:	c8 01       	movw	r24, r16
    10e4:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    10e8:	0e 94 4c 0b 	call	0x1698	; 0x1698 <xTaskResumeAll>
    10ec:	9c cf       	rjmp	.-200    	; 0x1026 <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    10ee:	c8 01       	movw	r24, r16
    10f0:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    10f4:	0e 94 4c 0b 	call	0x1698	; 0x1698 <xTaskResumeAll>
    10f8:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    10fa:	0f 90       	pop	r0
    10fc:	0f 90       	pop	r0
    10fe:	0f 90       	pop	r0
    1100:	0f 90       	pop	r0
    1102:	0f 90       	pop	r0
    1104:	cf 91       	pop	r28
    1106:	df 91       	pop	r29
    1108:	1f 91       	pop	r17
    110a:	0f 91       	pop	r16
    110c:	ff 90       	pop	r15
    110e:	ef 90       	pop	r14
    1110:	df 90       	pop	r13
    1112:	cf 90       	pop	r12
    1114:	bf 90       	pop	r11
    1116:	af 90       	pop	r10
    1118:	9f 90       	pop	r9
    111a:	8f 90       	pop	r8
    111c:	7f 90       	pop	r7
    111e:	08 95       	ret

00001120 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    1120:	af 92       	push	r10
    1122:	bf 92       	push	r11
    1124:	cf 92       	push	r12
    1126:	df 92       	push	r13
    1128:	ef 92       	push	r14
    112a:	ff 92       	push	r15
    112c:	0f 93       	push	r16
    112e:	1f 93       	push	r17
    1130:	cf 93       	push	r28
    1132:	df 93       	push	r29
    1134:	b8 2e       	mov	r11, r24
    1136:	a6 2e       	mov	r10, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1138:	88 23       	and	r24, r24
    113a:	09 f4       	brne	.+2      	; 0x113e <xQueueCreate+0x1e>
    113c:	42 c0       	rjmp	.+132    	; 0x11c2 <xQueueCreate+0xa2>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    113e:	8f e1       	ldi	r24, 0x1F	; 31
    1140:	90 e0       	ldi	r25, 0x00	; 0
    1142:	0e 94 18 04 	call	0x830	; 0x830 <pvPortMalloc>
    1146:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1148:	00 97       	sbiw	r24, 0x00	; 0
    114a:	d9 f1       	breq	.+118    	; 0x11c2 <xQueueCreate+0xa2>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    114c:	eb 2c       	mov	r14, r11
    114e:	ff 24       	eor	r15, r15
    1150:	ca 2c       	mov	r12, r10
    1152:	dd 24       	eor	r13, r13
    1154:	ce 9c       	mul	r12, r14
    1156:	80 01       	movw	r16, r0
    1158:	cf 9c       	mul	r12, r15
    115a:	10 0d       	add	r17, r0
    115c:	de 9c       	mul	r13, r14
    115e:	10 0d       	add	r17, r0
    1160:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1162:	c8 01       	movw	r24, r16
    1164:	01 96       	adiw	r24, 0x01	; 1
    1166:	0e 94 18 04 	call	0x830	; 0x830 <pvPortMalloc>
    116a:	9c 01       	movw	r18, r24
    116c:	99 83       	std	Y+1, r25	; 0x01
    116e:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    1170:	00 97       	sbiw	r24, 0x00	; 0
    1172:	21 f1       	breq	.+72     	; 0x11bc <xQueueCreate+0x9c>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1174:	08 0f       	add	r16, r24
    1176:	19 1f       	adc	r17, r25
    1178:	1b 83       	std	Y+3, r17	; 0x03
    117a:	0a 83       	std	Y+2, r16	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    117c:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    117e:	9d 83       	std	Y+5, r25	; 0x05
    1180:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    1182:	08 94       	sec
    1184:	e1 08       	sbc	r14, r1
    1186:	f1 08       	sbc	r15, r1
    1188:	ec 9c       	mul	r14, r12
    118a:	c0 01       	movw	r24, r0
    118c:	ed 9c       	mul	r14, r13
    118e:	90 0d       	add	r25, r0
    1190:	fc 9c       	mul	r15, r12
    1192:	90 0d       	add	r25, r0
    1194:	11 24       	eor	r1, r1
    1196:	28 0f       	add	r18, r24
    1198:	39 1f       	adc	r19, r25
    119a:	3f 83       	std	Y+7, r19	; 0x07
    119c:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    119e:	bb 8e       	std	Y+27, r11	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    11a0:	ac 8e       	std	Y+28, r10	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    11a2:	8f ef       	ldi	r24, 0xFF	; 255
    11a4:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    11a6:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    11a8:	ce 01       	movw	r24, r28
    11aa:	08 96       	adiw	r24, 0x08	; 8
    11ac:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    11b0:	ce 01       	movw	r24, r28
    11b2:	41 96       	adiw	r24, 0x11	; 17
    11b4:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>
    11b8:	9e 01       	movw	r18, r28
    11ba:	05 c0       	rjmp	.+10     	; 0x11c6 <xQueueCreate+0xa6>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    11bc:	ce 01       	movw	r24, r28
    11be:	0e 94 08 04 	call	0x810	; 0x810 <vPortFree>
    11c2:	20 e0       	ldi	r18, 0x00	; 0
    11c4:	30 e0       	ldi	r19, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    11c6:	c9 01       	movw	r24, r18
    11c8:	df 91       	pop	r29
    11ca:	cf 91       	pop	r28
    11cc:	1f 91       	pop	r17
    11ce:	0f 91       	pop	r16
    11d0:	ff 90       	pop	r15
    11d2:	ef 90       	pop	r14
    11d4:	df 90       	pop	r13
    11d6:	cf 90       	pop	r12
    11d8:	bf 90       	pop	r11
    11da:	af 90       	pop	r10
    11dc:	08 95       	ret

000011de <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
    11de:	1f 93       	push	r17
    11e0:	16 2f       	mov	r17, r22
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
    11e2:	60 e0       	ldi	r22, 0x00	; 0
    11e4:	0e 94 90 08 	call	0x1120	; 0x1120 <xQueueCreate>
    11e8:	fc 01       	movw	r30, r24

		if( pxHandle != NULL )
    11ea:	00 97       	sbiw	r24, 0x00	; 0
    11ec:	09 f0       	breq	.+2      	; 0x11f0 <xQueueCreateCountingSemaphore+0x12>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
    11ee:	12 8f       	std	Z+26, r17	; 0x1a
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
	}
    11f0:	cf 01       	movw	r24, r30
    11f2:	1f 91       	pop	r17
    11f4:	08 95       	ret

000011f6 <xTaskIsTaskSuspended>:
#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    11f6:	fc 01       	movw	r30, r24
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    11f8:	82 85       	ldd	r24, Z+10	; 0x0a
    11fa:	93 85       	ldd	r25, Z+11	; 0x0b
    11fc:	82 5e       	subi	r24, 0xE2	; 226
    11fe:	96 40       	sbci	r25, 0x06	; 6
    1200:	59 f4       	brne	.+22     	; 0x1218 <xTaskIsTaskSuspended+0x22>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    1202:	84 89       	ldd	r24, Z+20	; 0x14
    1204:	95 89       	ldd	r25, Z+21	; 0x15
    1206:	26 e0       	ldi	r18, 0x06	; 6
    1208:	80 3d       	cpi	r24, 0xD0	; 208
    120a:	92 07       	cpc	r25, r18
    120c:	29 f0       	breq	.+10     	; 0x1218 <xTaskIsTaskSuspended+0x22>
    120e:	20 e0       	ldi	r18, 0x00	; 0
    1210:	89 2b       	or	r24, r25
    1212:	19 f4       	brne	.+6      	; 0x121a <xTaskIsTaskSuspended+0x24>
    1214:	21 e0       	ldi	r18, 0x01	; 1
    1216:	01 c0       	rjmp	.+2      	; 0x121a <xTaskIsTaskSuspended+0x24>
    1218:	20 e0       	ldi	r18, 0x00	; 0
				}
			}
		}

		return xReturn;
	}
    121a:	82 2f       	mov	r24, r18
    121c:	08 95       	ret

0000121e <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    121e:	80 91 8e 06 	lds	r24, 0x068E
    1222:	8f 5f       	subi	r24, 0xFF	; 255
    1224:	80 93 8e 06 	sts	0x068E, r24
}
    1228:	08 95       	ret

0000122a <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    122a:	0f b6       	in	r0, 0x3f	; 63
    122c:	f8 94       	cli
    122e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1230:	20 91 8c 06 	lds	r18, 0x068C
    1234:	30 91 8d 06 	lds	r19, 0x068D
	}
	taskEXIT_CRITICAL();
    1238:	0f 90       	pop	r0
    123a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    123c:	c9 01       	movw	r24, r18
    123e:	08 95       	ret

00001240 <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    1240:	20 91 8c 06 	lds	r18, 0x068C
    1244:	30 91 8d 06 	lds	r19, 0x068D
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1248:	c9 01       	movw	r24, r18
    124a:	08 95       	ret

0000124c <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    124c:	80 91 91 06 	lds	r24, 0x0691
}
    1250:	08 95       	ret

00001252 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1252:	80 91 8e 06 	lds	r24, 0x068E
    1256:	88 23       	and	r24, r24
    1258:	51 f0       	breq	.+20     	; 0x126e <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    125a:	81 e0       	ldi	r24, 0x01	; 1
    125c:	80 93 8a 06 	sts	0x068A, r24
    1260:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1262:	80 91 8f 06 	lds	r24, 0x068F
    1266:	81 50       	subi	r24, 0x01	; 1
    1268:	80 93 8f 06 	sts	0x068F, r24
    126c:	01 c0       	rjmp	.+2      	; 0x1270 <vTaskSwitchContext+0x1e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    126e:	99 e0       	ldi	r25, 0x09	; 9
    1270:	e0 91 8f 06 	lds	r30, 0x068F
    1274:	e9 9f       	mul	r30, r25
    1276:	f0 01       	movw	r30, r0
    1278:	11 24       	eor	r1, r1
    127a:	ea 56       	subi	r30, 0x6A	; 106
    127c:	f9 4f       	sbci	r31, 0xF9	; 249
    127e:	80 81       	ld	r24, Z
    1280:	88 23       	and	r24, r24
    1282:	79 f3       	breq	.-34     	; 0x1262 <vTaskSwitchContext+0x10>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1284:	90 91 8f 06 	lds	r25, 0x068F
    1288:	89 e0       	ldi	r24, 0x09	; 9
    128a:	98 9f       	mul	r25, r24
    128c:	d0 01       	movw	r26, r0
    128e:	11 24       	eor	r1, r1
    1290:	aa 56       	subi	r26, 0x6A	; 106
    1292:	b9 4f       	sbci	r27, 0xF9	; 249
    1294:	11 96       	adiw	r26, 0x01	; 1
    1296:	ed 91       	ld	r30, X+
    1298:	fc 91       	ld	r31, X
    129a:	12 97       	sbiw	r26, 0x02	; 2
    129c:	02 80       	ldd	r0, Z+2	; 0x02
    129e:	f3 81       	ldd	r31, Z+3	; 0x03
    12a0:	e0 2d       	mov	r30, r0
    12a2:	12 96       	adiw	r26, 0x02	; 2
    12a4:	fc 93       	st	X, r31
    12a6:	ee 93       	st	-X, r30
    12a8:	11 97       	sbiw	r26, 0x01	; 1
    12aa:	cd 01       	movw	r24, r26
    12ac:	03 96       	adiw	r24, 0x03	; 3
    12ae:	e8 17       	cp	r30, r24
    12b0:	f9 07       	cpc	r31, r25
    12b2:	31 f4       	brne	.+12     	; 0x12c0 <vTaskSwitchContext+0x6e>
    12b4:	82 81       	ldd	r24, Z+2	; 0x02
    12b6:	93 81       	ldd	r25, Z+3	; 0x03
    12b8:	12 96       	adiw	r26, 0x02	; 2
    12ba:	9c 93       	st	X, r25
    12bc:	8e 93       	st	-X, r24
    12be:	11 97       	sbiw	r26, 0x01	; 1
    12c0:	11 96       	adiw	r26, 0x01	; 1
    12c2:	ed 91       	ld	r30, X+
    12c4:	fc 91       	ld	r31, X
    12c6:	12 97       	sbiw	r26, 0x02	; 2
    12c8:	86 81       	ldd	r24, Z+6	; 0x06
    12ca:	97 81       	ldd	r25, Z+7	; 0x07
    12cc:	90 93 89 06 	sts	0x0689, r25
    12d0:	80 93 88 06 	sts	0x0688, r24
    12d4:	08 95       	ret

000012d6 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    12d6:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    12d8:	80 91 8b 06 	lds	r24, 0x068B
    12dc:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    12de:	80 91 8c 06 	lds	r24, 0x068C
    12e2:	90 91 8d 06 	lds	r25, 0x068D
    12e6:	92 83       	std	Z+2, r25	; 0x02
    12e8:	81 83       	std	Z+1, r24	; 0x01
}
    12ea:	08 95       	ret

000012ec <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    12ec:	fc 01       	movw	r30, r24
    12ee:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    12f0:	0f b6       	in	r0, 0x3f	; 63
    12f2:	f8 94       	cli
    12f4:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    12f6:	4d 91       	ld	r20, X+
    12f8:	5c 91       	ld	r21, X
    12fa:	11 97       	sbiw	r26, 0x01	; 1
    12fc:	8f ef       	ldi	r24, 0xFF	; 255
    12fe:	4f 3f       	cpi	r20, 0xFF	; 255
    1300:	58 07       	cpc	r21, r24
    1302:	61 f1       	breq	.+88     	; 0x135c <xTaskCheckForTimeOut+0x70>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1304:	90 91 8b 06 	lds	r25, 0x068B
    1308:	80 81       	ld	r24, Z
    130a:	98 17       	cp	r25, r24
    130c:	49 f0       	breq	.+18     	; 0x1320 <xTaskCheckForTimeOut+0x34>
    130e:	20 91 8c 06 	lds	r18, 0x068C
    1312:	30 91 8d 06 	lds	r19, 0x068D
    1316:	81 81       	ldd	r24, Z+1	; 0x01
    1318:	92 81       	ldd	r25, Z+2	; 0x02
    131a:	28 17       	cp	r18, r24
    131c:	39 07       	cpc	r19, r25
    131e:	00 f5       	brcc	.+64     	; 0x1360 <xTaskCheckForTimeOut+0x74>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1320:	80 91 8c 06 	lds	r24, 0x068C
    1324:	90 91 8d 06 	lds	r25, 0x068D
    1328:	21 81       	ldd	r18, Z+1	; 0x01
    132a:	32 81       	ldd	r19, Z+2	; 0x02
    132c:	82 1b       	sub	r24, r18
    132e:	93 0b       	sbc	r25, r19
    1330:	84 17       	cp	r24, r20
    1332:	95 07       	cpc	r25, r21
    1334:	a8 f4       	brcc	.+42     	; 0x1360 <xTaskCheckForTimeOut+0x74>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1336:	80 91 8c 06 	lds	r24, 0x068C
    133a:	90 91 8d 06 	lds	r25, 0x068D
    133e:	28 1b       	sub	r18, r24
    1340:	39 0b       	sbc	r19, r25
    1342:	24 0f       	add	r18, r20
    1344:	35 1f       	adc	r19, r21
    1346:	2d 93       	st	X+, r18
    1348:	3c 93       	st	X, r19
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    134a:	80 91 8b 06 	lds	r24, 0x068B
    134e:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    1350:	80 91 8c 06 	lds	r24, 0x068C
    1354:	90 91 8d 06 	lds	r25, 0x068D
    1358:	92 83       	std	Z+2, r25	; 0x02
    135a:	81 83       	std	Z+1, r24	; 0x01
    135c:	80 e0       	ldi	r24, 0x00	; 0
    135e:	01 c0       	rjmp	.+2      	; 0x1362 <xTaskCheckForTimeOut+0x76>
    1360:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    1362:	0f 90       	pop	r0
    1364:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1366:	08 95       	ret

00001368 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1368:	81 e0       	ldi	r24, 0x01	; 1
    136a:	80 93 8a 06 	sts	0x068A, r24
}
    136e:	08 95       	ret

00001370 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1370:	0f 93       	push	r16
    1372:	1f 93       	push	r17
    1374:	cf 93       	push	r28
    1376:	df 93       	push	r29
    1378:	fc 01       	movw	r30, r24
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    137a:	05 80       	ldd	r0, Z+5	; 0x05
    137c:	f6 81       	ldd	r31, Z+6	; 0x06
    137e:	e0 2d       	mov	r30, r0
    1380:	06 81       	ldd	r16, Z+6	; 0x06
    1382:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1384:	e8 01       	movw	r28, r16
    1386:	2c 96       	adiw	r28, 0x0c	; 12
    1388:	ce 01       	movw	r24, r28
    138a:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    138e:	80 91 8e 06 	lds	r24, 0x068E
    1392:	88 23       	and	r24, r24
    1394:	a9 f4       	brne	.+42     	; 0x13c0 <xTaskRemoveFromEventList+0x50>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1396:	e8 01       	movw	r28, r16
    1398:	22 96       	adiw	r28, 0x02	; 2
    139a:	ce 01       	movw	r24, r28
    139c:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    13a0:	d8 01       	movw	r26, r16
    13a2:	56 96       	adiw	r26, 0x16	; 22
    13a4:	9c 91       	ld	r25, X
    13a6:	80 91 8f 06 	lds	r24, 0x068F
    13aa:	89 17       	cp	r24, r25
    13ac:	10 f4       	brcc	.+4      	; 0x13b2 <xTaskRemoveFromEventList+0x42>
    13ae:	90 93 8f 06 	sts	0x068F, r25
    13b2:	89 e0       	ldi	r24, 0x09	; 9
    13b4:	98 9f       	mul	r25, r24
    13b6:	c0 01       	movw	r24, r0
    13b8:	11 24       	eor	r1, r1
    13ba:	8a 56       	subi	r24, 0x6A	; 106
    13bc:	99 4f       	sbci	r25, 0xF9	; 249
    13be:	02 c0       	rjmp	.+4      	; 0x13c4 <xTaskRemoveFromEventList+0x54>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    13c0:	80 ed       	ldi	r24, 0xD0	; 208
    13c2:	96 e0       	ldi	r25, 0x06	; 6
    13c4:	be 01       	movw	r22, r28
    13c6:	0e 94 53 04 	call	0x8a6	; 0x8a6 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    13ca:	e0 91 88 06 	lds	r30, 0x0688
    13ce:	f0 91 89 06 	lds	r31, 0x0689
    13d2:	20 e0       	ldi	r18, 0x00	; 0
    13d4:	d8 01       	movw	r26, r16
    13d6:	56 96       	adiw	r26, 0x16	; 22
    13d8:	9c 91       	ld	r25, X
    13da:	86 89       	ldd	r24, Z+22	; 0x16
    13dc:	98 17       	cp	r25, r24
    13de:	08 f0       	brcs	.+2      	; 0x13e2 <xTaskRemoveFromEventList+0x72>
    13e0:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    13e2:	82 2f       	mov	r24, r18
    13e4:	df 91       	pop	r29
    13e6:	cf 91       	pop	r28
    13e8:	1f 91       	pop	r17
    13ea:	0f 91       	pop	r16
    13ec:	08 95       	ret

000013ee <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    13ee:	ff 92       	push	r15
    13f0:	0f 93       	push	r16
    13f2:	1f 93       	push	r17
    13f4:	cf 93       	push	r28
    13f6:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    13f8:	80 91 8e 06 	lds	r24, 0x068E
    13fc:	88 23       	and	r24, r24
    13fe:	09 f0       	breq	.+2      	; 0x1402 <vTaskIncrementTick+0x14>
    1400:	8f c0       	rjmp	.+286    	; 0x1520 <vTaskIncrementTick+0x132>
	{
		++xTickCount;
    1402:	80 91 8c 06 	lds	r24, 0x068C
    1406:	90 91 8d 06 	lds	r25, 0x068D
    140a:	01 96       	adiw	r24, 0x01	; 1
    140c:	90 93 8d 06 	sts	0x068D, r25
    1410:	80 93 8c 06 	sts	0x068C, r24
		if( xTickCount == ( portTickType ) 0U )
    1414:	80 91 8c 06 	lds	r24, 0x068C
    1418:	90 91 8d 06 	lds	r25, 0x068D
    141c:	89 2b       	or	r24, r25
    141e:	79 f5       	brne	.+94     	; 0x147e <vTaskIncrementTick+0x90>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1420:	20 91 cc 06 	lds	r18, 0x06CC
    1424:	30 91 cd 06 	lds	r19, 0x06CD
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1428:	80 91 ce 06 	lds	r24, 0x06CE
    142c:	90 91 cf 06 	lds	r25, 0x06CF
    1430:	90 93 cd 06 	sts	0x06CD, r25
    1434:	80 93 cc 06 	sts	0x06CC, r24
			pxOverflowDelayedTaskList = pxTemp;
    1438:	30 93 cf 06 	sts	0x06CF, r19
    143c:	20 93 ce 06 	sts	0x06CE, r18
			xNumOfOverflows++;
    1440:	80 91 8b 06 	lds	r24, 0x068B
    1444:	8f 5f       	subi	r24, 0xFF	; 255
    1446:	80 93 8b 06 	sts	0x068B, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    144a:	e0 91 cc 06 	lds	r30, 0x06CC
    144e:	f0 91 cd 06 	lds	r31, 0x06CD
    1452:	80 81       	ld	r24, Z
    1454:	88 23       	and	r24, r24
    1456:	19 f4       	brne	.+6      	; 0x145e <vTaskIncrementTick+0x70>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1458:	8f ef       	ldi	r24, 0xFF	; 255
    145a:	9f ef       	ldi	r25, 0xFF	; 255
    145c:	0c c0       	rjmp	.+24     	; 0x1476 <vTaskIncrementTick+0x88>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    145e:	e0 91 cc 06 	lds	r30, 0x06CC
    1462:	f0 91 cd 06 	lds	r31, 0x06CD
    1466:	05 80       	ldd	r0, Z+5	; 0x05
    1468:	f6 81       	ldd	r31, Z+6	; 0x06
    146a:	e0 2d       	mov	r30, r0
    146c:	06 80       	ldd	r0, Z+6	; 0x06
    146e:	f7 81       	ldd	r31, Z+7	; 0x07
    1470:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1472:	82 81       	ldd	r24, Z+2	; 0x02
    1474:	93 81       	ldd	r25, Z+3	; 0x03
    1476:	90 93 66 00 	sts	0x0066, r25
    147a:	80 93 65 00 	sts	0x0065, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    147e:	20 91 8c 06 	lds	r18, 0x068C
    1482:	30 91 8d 06 	lds	r19, 0x068D
    1486:	80 91 65 00 	lds	r24, 0x0065
    148a:	90 91 66 00 	lds	r25, 0x0066
    148e:	28 17       	cp	r18, r24
    1490:	39 07       	cpc	r19, r25
    1492:	08 f4       	brcc	.+2      	; 0x1496 <vTaskIncrementTick+0xa8>
    1494:	4a c0       	rjmp	.+148    	; 0x152a <vTaskIncrementTick+0x13c>
    1496:	89 e0       	ldi	r24, 0x09	; 9
    1498:	f8 2e       	mov	r15, r24
    149a:	e0 91 cc 06 	lds	r30, 0x06CC
    149e:	f0 91 cd 06 	lds	r31, 0x06CD
    14a2:	80 81       	ld	r24, Z
    14a4:	88 23       	and	r24, r24
    14a6:	39 f4       	brne	.+14     	; 0x14b6 <vTaskIncrementTick+0xc8>
    14a8:	8f ef       	ldi	r24, 0xFF	; 255
    14aa:	9f ef       	ldi	r25, 0xFF	; 255
    14ac:	90 93 66 00 	sts	0x0066, r25
    14b0:	80 93 65 00 	sts	0x0065, r24
    14b4:	3a c0       	rjmp	.+116    	; 0x152a <vTaskIncrementTick+0x13c>
    14b6:	e0 91 cc 06 	lds	r30, 0x06CC
    14ba:	f0 91 cd 06 	lds	r31, 0x06CD
    14be:	05 80       	ldd	r0, Z+5	; 0x05
    14c0:	f6 81       	ldd	r31, Z+6	; 0x06
    14c2:	e0 2d       	mov	r30, r0
    14c4:	c6 81       	ldd	r28, Z+6	; 0x06
    14c6:	d7 81       	ldd	r29, Z+7	; 0x07
    14c8:	2a 81       	ldd	r18, Y+2	; 0x02
    14ca:	3b 81       	ldd	r19, Y+3	; 0x03
    14cc:	80 91 8c 06 	lds	r24, 0x068C
    14d0:	90 91 8d 06 	lds	r25, 0x068D
    14d4:	82 17       	cp	r24, r18
    14d6:	93 07       	cpc	r25, r19
    14d8:	28 f4       	brcc	.+10     	; 0x14e4 <vTaskIncrementTick+0xf6>
    14da:	30 93 66 00 	sts	0x0066, r19
    14de:	20 93 65 00 	sts	0x0065, r18
    14e2:	23 c0       	rjmp	.+70     	; 0x152a <vTaskIncrementTick+0x13c>
    14e4:	8e 01       	movw	r16, r28
    14e6:	0e 5f       	subi	r16, 0xFE	; 254
    14e8:	1f 4f       	sbci	r17, 0xFF	; 255
    14ea:	c8 01       	movw	r24, r16
    14ec:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>
    14f0:	8c 89       	ldd	r24, Y+20	; 0x14
    14f2:	9d 89       	ldd	r25, Y+21	; 0x15
    14f4:	89 2b       	or	r24, r25
    14f6:	21 f0       	breq	.+8      	; 0x1500 <vTaskIncrementTick+0x112>
    14f8:	ce 01       	movw	r24, r28
    14fa:	0c 96       	adiw	r24, 0x0c	; 12
    14fc:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>
    1500:	9e 89       	ldd	r25, Y+22	; 0x16
    1502:	80 91 8f 06 	lds	r24, 0x068F
    1506:	89 17       	cp	r24, r25
    1508:	10 f4       	brcc	.+4      	; 0x150e <vTaskIncrementTick+0x120>
    150a:	90 93 8f 06 	sts	0x068F, r25
    150e:	9f 9d       	mul	r25, r15
    1510:	c0 01       	movw	r24, r0
    1512:	11 24       	eor	r1, r1
    1514:	8a 56       	subi	r24, 0x6A	; 106
    1516:	99 4f       	sbci	r25, 0xF9	; 249
    1518:	b8 01       	movw	r22, r16
    151a:	0e 94 53 04 	call	0x8a6	; 0x8a6 <vListInsertEnd>
    151e:	bd cf       	rjmp	.-134    	; 0x149a <vTaskIncrementTick+0xac>
	}
	else
	{
		++uxMissedTicks;
    1520:	80 91 90 06 	lds	r24, 0x0690
    1524:	8f 5f       	subi	r24, 0xFF	; 255
    1526:	80 93 90 06 	sts	0x0690, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    152a:	df 91       	pop	r29
    152c:	cf 91       	pop	r28
    152e:	1f 91       	pop	r17
    1530:	0f 91       	pop	r16
    1532:	ff 90       	pop	r15
    1534:	08 95       	ret

00001536 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    1536:	df 92       	push	r13
    1538:	ef 92       	push	r14
    153a:	ff 92       	push	r15
    153c:	0f 93       	push	r16
    153e:	1f 93       	push	r17
    1540:	cf 93       	push	r28
    1542:	df 93       	push	r29
	portBASE_TYPE xYieldRequired = pdFALSE;
	tskTCB *pxTCB;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
    1544:	ec 01       	movw	r28, r24
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1546:	8a 85       	ldd	r24, Y+10	; 0x0a
    1548:	9b 85       	ldd	r25, Y+11	; 0x0b
    154a:	82 5e       	subi	r24, 0xE2	; 226
    154c:	96 40       	sbci	r25, 0x06	; 6
    154e:	91 f5       	brne	.+100    	; 0x15b4 <xTaskResumeFromISR+0x7e>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    1550:	8c 89       	ldd	r24, Y+20	; 0x14
    1552:	9d 89       	ldd	r25, Y+21	; 0x15
    1554:	26 e0       	ldi	r18, 0x06	; 6
    1556:	80 3d       	cpi	r24, 0xD0	; 208
    1558:	92 07       	cpc	r25, r18
    155a:	61 f1       	breq	.+88     	; 0x15b4 <xTaskResumeFromISR+0x7e>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    155c:	89 2b       	or	r24, r25
    155e:	51 f5       	brne	.+84     	; 0x15b4 <xTaskResumeFromISR+0x7e>
    1560:	33 c0       	rjmp	.+102    	; 0x15c8 <xTaskResumeFromISR+0x92>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    1562:	de 88       	ldd	r13, Y+22	; 0x16
    1564:	e0 91 88 06 	lds	r30, 0x0688
    1568:	f0 91 89 06 	lds	r31, 0x0689
    156c:	06 89       	ldd	r16, Z+22	; 0x16
				vListRemove(  &( pxTCB->xGenericListItem ) );
    156e:	92 e0       	ldi	r25, 0x02	; 2
    1570:	e9 2e       	mov	r14, r25
    1572:	f1 2c       	mov	r15, r1
    1574:	ec 0e       	add	r14, r28
    1576:	fd 1e       	adc	r15, r29
    1578:	c7 01       	movw	r24, r14
    157a:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
    157e:	6e 89       	ldd	r22, Y+22	; 0x16
    1580:	80 91 8f 06 	lds	r24, 0x068F
    1584:	86 17       	cp	r24, r22
    1586:	10 f4       	brcc	.+4      	; 0x158c <xTaskResumeFromISR+0x56>
    1588:	60 93 8f 06 	sts	0x068F, r22
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    158c:	10 e0       	ldi	r17, 0x00	; 0
    158e:	d0 16       	cp	r13, r16
    1590:	08 f0       	brcs	.+2      	; 0x1594 <xTaskResumeFromISR+0x5e>
    1592:	11 e0       	ldi	r17, 0x01	; 1
				vListRemove(  &( pxTCB->xGenericListItem ) );
				prvAddTaskToReadyQueue( pxTCB );
    1594:	89 e0       	ldi	r24, 0x09	; 9
    1596:	68 9f       	mul	r22, r24
    1598:	c0 01       	movw	r24, r0
    159a:	11 24       	eor	r1, r1
    159c:	8a 56       	subi	r24, 0x6A	; 106
    159e:	99 4f       	sbci	r25, 0xF9	; 249
    15a0:	b7 01       	movw	r22, r14
    15a2:	0e 94 53 04 	call	0x8a6	; 0x8a6 <vListInsertEnd>
    15a6:	07 c0       	rjmp	.+14     	; 0x15b6 <xTaskResumeFromISR+0x80>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    15a8:	2c 96       	adiw	r28, 0x0c	; 12
    15aa:	80 ed       	ldi	r24, 0xD0	; 208
    15ac:	96 e0       	ldi	r25, 0x06	; 6
    15ae:	be 01       	movw	r22, r28
    15b0:	0e 94 53 04 	call	0x8a6	; 0x8a6 <vListInsertEnd>
    15b4:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		return xYieldRequired;
	}
    15b6:	81 2f       	mov	r24, r17
    15b8:	df 91       	pop	r29
    15ba:	cf 91       	pop	r28
    15bc:	1f 91       	pop	r17
    15be:	0f 91       	pop	r16
    15c0:	ff 90       	pop	r15
    15c2:	ef 90       	pop	r14
    15c4:	df 90       	pop	r13
    15c6:	08 95       	ret

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    15c8:	80 91 8e 06 	lds	r24, 0x068E
    15cc:	88 23       	and	r24, r24
    15ce:	49 f2       	breq	.-110    	; 0x1562 <xTaskResumeFromISR+0x2c>
    15d0:	eb cf       	rjmp	.-42     	; 0x15a8 <xTaskResumeFromISR+0x72>

000015d2 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    15d2:	cf 93       	push	r28
    15d4:	df 93       	push	r29
    15d6:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    15d8:	e0 91 88 06 	lds	r30, 0x0688
    15dc:	f0 91 89 06 	lds	r31, 0x0689
    15e0:	93 83       	std	Z+3, r25	; 0x03
    15e2:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    15e4:	80 91 8c 06 	lds	r24, 0x068C
    15e8:	90 91 8d 06 	lds	r25, 0x068D
    15ec:	c8 17       	cp	r28, r24
    15ee:	d9 07       	cpc	r29, r25
    15f0:	68 f4       	brcc	.+26     	; 0x160c <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    15f2:	80 91 ce 06 	lds	r24, 0x06CE
    15f6:	90 91 cf 06 	lds	r25, 0x06CF
    15fa:	60 91 88 06 	lds	r22, 0x0688
    15fe:	70 91 89 06 	lds	r23, 0x0689
    1602:	6e 5f       	subi	r22, 0xFE	; 254
    1604:	7f 4f       	sbci	r23, 0xFF	; 255
    1606:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <vListInsert>
    160a:	17 c0       	rjmp	.+46     	; 0x163a <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    160c:	80 91 cc 06 	lds	r24, 0x06CC
    1610:	90 91 cd 06 	lds	r25, 0x06CD
    1614:	60 91 88 06 	lds	r22, 0x0688
    1618:	70 91 89 06 	lds	r23, 0x0689
    161c:	6e 5f       	subi	r22, 0xFE	; 254
    161e:	7f 4f       	sbci	r23, 0xFF	; 255
    1620:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1624:	80 91 65 00 	lds	r24, 0x0065
    1628:	90 91 66 00 	lds	r25, 0x0066
    162c:	c8 17       	cp	r28, r24
    162e:	d9 07       	cpc	r29, r25
    1630:	20 f4       	brcc	.+8      	; 0x163a <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1632:	d0 93 66 00 	sts	0x0066, r29
    1636:	c0 93 65 00 	sts	0x0065, r28
		}
	}
}
    163a:	df 91       	pop	r29
    163c:	cf 91       	pop	r28
    163e:	08 95       	ret

00001640 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1640:	cf 93       	push	r28
    1642:	df 93       	push	r29
    1644:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1646:	60 91 88 06 	lds	r22, 0x0688
    164a:	70 91 89 06 	lds	r23, 0x0689
    164e:	64 5f       	subi	r22, 0xF4	; 244
    1650:	7f 4f       	sbci	r23, 0xFF	; 255
    1652:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1656:	80 91 88 06 	lds	r24, 0x0688
    165a:	90 91 89 06 	lds	r25, 0x0689
    165e:	02 96       	adiw	r24, 0x02	; 2
    1660:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    1664:	8f ef       	ldi	r24, 0xFF	; 255
    1666:	cf 3f       	cpi	r28, 0xFF	; 255
    1668:	d8 07       	cpc	r29, r24
    166a:	59 f4       	brne	.+22     	; 0x1682 <vTaskPlaceOnEventList+0x42>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    166c:	60 91 88 06 	lds	r22, 0x0688
    1670:	70 91 89 06 	lds	r23, 0x0689
    1674:	6e 5f       	subi	r22, 0xFE	; 254
    1676:	7f 4f       	sbci	r23, 0xFF	; 255
    1678:	82 ee       	ldi	r24, 0xE2	; 226
    167a:	96 e0       	ldi	r25, 0x06	; 6
    167c:	0e 94 53 04 	call	0x8a6	; 0x8a6 <vListInsertEnd>
    1680:	08 c0       	rjmp	.+16     	; 0x1692 <vTaskPlaceOnEventList+0x52>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1682:	80 91 8c 06 	lds	r24, 0x068C
    1686:	90 91 8d 06 	lds	r25, 0x068D
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    168a:	8c 0f       	add	r24, r28
    168c:	9d 1f       	adc	r25, r29
    168e:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    1692:	df 91       	pop	r29
    1694:	cf 91       	pop	r28
    1696:	08 95       	ret

00001698 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1698:	cf 92       	push	r12
    169a:	df 92       	push	r13
    169c:	ff 92       	push	r15
    169e:	0f 93       	push	r16
    16a0:	1f 93       	push	r17
    16a2:	df 93       	push	r29
    16a4:	cf 93       	push	r28
    16a6:	0f 92       	push	r0
    16a8:	cd b7       	in	r28, 0x3d	; 61
    16aa:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    16ac:	0f b6       	in	r0, 0x3f	; 63
    16ae:	f8 94       	cli
    16b0:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    16b2:	80 91 8e 06 	lds	r24, 0x068E
    16b6:	81 50       	subi	r24, 0x01	; 1
    16b8:	80 93 8e 06 	sts	0x068E, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    16bc:	80 91 8e 06 	lds	r24, 0x068E
    16c0:	88 23       	and	r24, r24
    16c2:	09 f0       	breq	.+2      	; 0x16c6 <xTaskResumeAll+0x2e>
    16c4:	58 c0       	rjmp	.+176    	; 0x1776 <xTaskResumeAll+0xde>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    16c6:	80 91 91 06 	lds	r24, 0x0691
    16ca:	88 23       	and	r24, r24
    16cc:	09 f4       	brne	.+2      	; 0x16d0 <xTaskResumeAll+0x38>
    16ce:	53 c0       	rjmp	.+166    	; 0x1776 <xTaskResumeAll+0xde>
    16d0:	19 82       	std	Y+1, r1	; 0x01
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    16d2:	29 e0       	ldi	r18, 0x09	; 9
    16d4:	f2 2e       	mov	r15, r18
    16d6:	2d c0       	rjmp	.+90     	; 0x1732 <xTaskResumeAll+0x9a>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    16d8:	e0 91 d5 06 	lds	r30, 0x06D5
    16dc:	f0 91 d6 06 	lds	r31, 0x06D6
    16e0:	c6 80       	ldd	r12, Z+6	; 0x06
    16e2:	d7 80       	ldd	r13, Z+7	; 0x07
					vListRemove( &( pxTCB->xEventListItem ) );
    16e4:	c6 01       	movw	r24, r12
    16e6:	0c 96       	adiw	r24, 0x0c	; 12
    16e8:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    16ec:	86 01       	movw	r16, r12
    16ee:	0e 5f       	subi	r16, 0xFE	; 254
    16f0:	1f 4f       	sbci	r17, 0xFF	; 255
    16f2:	c8 01       	movw	r24, r16
    16f4:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    16f8:	d6 01       	movw	r26, r12
    16fa:	56 96       	adiw	r26, 0x16	; 22
    16fc:	9c 91       	ld	r25, X
    16fe:	80 91 8f 06 	lds	r24, 0x068F
    1702:	89 17       	cp	r24, r25
    1704:	10 f4       	brcc	.+4      	; 0x170a <xTaskResumeAll+0x72>
    1706:	90 93 8f 06 	sts	0x068F, r25
    170a:	9f 9d       	mul	r25, r15
    170c:	c0 01       	movw	r24, r0
    170e:	11 24       	eor	r1, r1
    1710:	8a 56       	subi	r24, 0x6A	; 106
    1712:	99 4f       	sbci	r25, 0xF9	; 249
    1714:	b8 01       	movw	r22, r16
    1716:	0e 94 53 04 	call	0x8a6	; 0x8a6 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    171a:	e0 91 88 06 	lds	r30, 0x0688
    171e:	f0 91 89 06 	lds	r31, 0x0689
    1722:	d6 01       	movw	r26, r12
    1724:	56 96       	adiw	r26, 0x16	; 22
    1726:	9c 91       	ld	r25, X
    1728:	86 89       	ldd	r24, Z+22	; 0x16
    172a:	98 17       	cp	r25, r24
    172c:	10 f0       	brcs	.+4      	; 0x1732 <xTaskResumeAll+0x9a>
    172e:	b1 e0       	ldi	r27, 0x01	; 1
    1730:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1732:	80 91 d0 06 	lds	r24, 0x06D0
    1736:	88 23       	and	r24, r24
    1738:	79 f6       	brne	.-98     	; 0x16d8 <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    173a:	80 91 90 06 	lds	r24, 0x0690
    173e:	88 23       	and	r24, r24
    1740:	41 f4       	brne	.+16     	; 0x1752 <xTaskResumeAll+0xba>
    1742:	0c c0       	rjmp	.+24     	; 0x175c <xTaskResumeAll+0xc4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    1744:	0e 94 f7 09 	call	0x13ee	; 0x13ee <vTaskIncrementTick>
						--uxMissedTicks;
    1748:	80 91 90 06 	lds	r24, 0x0690
    174c:	81 50       	subi	r24, 0x01	; 1
    174e:	80 93 90 06 	sts	0x0690, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1752:	80 91 90 06 	lds	r24, 0x0690
    1756:	88 23       	and	r24, r24
    1758:	a9 f7       	brne	.-22     	; 0x1744 <xTaskResumeAll+0xac>
    175a:	07 c0       	rjmp	.+14     	; 0x176a <xTaskResumeAll+0xd2>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    175c:	e9 81       	ldd	r30, Y+1	; 0x01
    175e:	e1 30       	cpi	r30, 0x01	; 1
    1760:	21 f0       	breq	.+8      	; 0x176a <xTaskResumeAll+0xd2>
    1762:	80 91 8a 06 	lds	r24, 0x068A
    1766:	81 30       	cpi	r24, 0x01	; 1
    1768:	31 f4       	brne	.+12     	; 0x1776 <xTaskResumeAll+0xde>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    176a:	10 92 8a 06 	sts	0x068A, r1
					portYIELD_WITHIN_API();
    176e:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vPortYield>
    1772:	81 e0       	ldi	r24, 0x01	; 1
    1774:	01 c0       	rjmp	.+2      	; 0x1778 <xTaskResumeAll+0xe0>
    1776:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1778:	0f 90       	pop	r0
    177a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    177c:	0f 90       	pop	r0
    177e:	cf 91       	pop	r28
    1780:	df 91       	pop	r29
    1782:	1f 91       	pop	r17
    1784:	0f 91       	pop	r16
    1786:	ff 90       	pop	r15
    1788:	df 90       	pop	r13
    178a:	cf 90       	pop	r12
    178c:	08 95       	ret

0000178e <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    178e:	0f 93       	push	r16
    1790:	1f 93       	push	r17
    1792:	cf 93       	push	r28
    1794:	df 93       	push	r29
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
    1796:	ec 01       	movw	r28, r24

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    1798:	00 97       	sbiw	r24, 0x00	; 0
    179a:	09 f4       	brne	.+2      	; 0x179e <vTaskResume+0x10>
    179c:	3c c0       	rjmp	.+120    	; 0x1816 <vTaskResume+0x88>
    179e:	80 91 88 06 	lds	r24, 0x0688
    17a2:	90 91 89 06 	lds	r25, 0x0689
    17a6:	c8 17       	cp	r28, r24
    17a8:	d9 07       	cpc	r29, r25
    17aa:	a9 f1       	breq	.+106    	; 0x1816 <vTaskResume+0x88>
		{
			taskENTER_CRITICAL();
    17ac:	0f b6       	in	r0, 0x3f	; 63
    17ae:	f8 94       	cli
    17b0:	0f 92       	push	r0
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    17b2:	8a 85       	ldd	r24, Y+10	; 0x0a
    17b4:	9b 85       	ldd	r25, Y+11	; 0x0b
    17b6:	82 5e       	subi	r24, 0xE2	; 226
    17b8:	96 40       	sbci	r25, 0x06	; 6
    17ba:	f1 f4       	brne	.+60     	; 0x17f8 <vTaskResume+0x6a>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    17bc:	8c 89       	ldd	r24, Y+20	; 0x14
    17be:	9d 89       	ldd	r25, Y+21	; 0x15
    17c0:	26 e0       	ldi	r18, 0x06	; 6
    17c2:	80 3d       	cpi	r24, 0xD0	; 208
    17c4:	92 07       	cpc	r25, r18
    17c6:	c1 f0       	breq	.+48     	; 0x17f8 <vTaskResume+0x6a>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    17c8:	89 2b       	or	r24, r25
    17ca:	b1 f4       	brne	.+44     	; 0x17f8 <vTaskResume+0x6a>
    17cc:	18 c0       	rjmp	.+48     	; 0x17fe <vTaskResume+0x70>
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    17ce:	90 93 8f 06 	sts	0x068F, r25
    17d2:	89 e0       	ldi	r24, 0x09	; 9
    17d4:	98 9f       	mul	r25, r24
    17d6:	c0 01       	movw	r24, r0
    17d8:	11 24       	eor	r1, r1
    17da:	8a 56       	subi	r24, 0x6A	; 106
    17dc:	99 4f       	sbci	r25, 0xF9	; 249
    17de:	b8 01       	movw	r22, r16
    17e0:	0e 94 53 04 	call	0x8a6	; 0x8a6 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    17e4:	e0 91 88 06 	lds	r30, 0x0688
    17e8:	f0 91 89 06 	lds	r31, 0x0689
    17ec:	9e 89       	ldd	r25, Y+22	; 0x16
    17ee:	86 89       	ldd	r24, Z+22	; 0x16
    17f0:	98 17       	cp	r25, r24
    17f2:	10 f0       	brcs	.+4      	; 0x17f8 <vTaskResume+0x6a>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    17f4:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
    17f8:	0f 90       	pop	r0
    17fa:	0f be       	out	0x3f, r0	; 63
    17fc:	0c c0       	rjmp	.+24     	; 0x1816 <vTaskResume+0x88>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    17fe:	8e 01       	movw	r16, r28
    1800:	0e 5f       	subi	r16, 0xFE	; 254
    1802:	1f 4f       	sbci	r17, 0xFF	; 255
    1804:	c8 01       	movw	r24, r16
    1806:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    180a:	9e 89       	ldd	r25, Y+22	; 0x16
    180c:	80 91 8f 06 	lds	r24, 0x068F
    1810:	89 17       	cp	r24, r25
    1812:	e8 f2       	brcs	.-70     	; 0x17ce <vTaskResume+0x40>
    1814:	de cf       	rjmp	.-68     	; 0x17d2 <vTaskResume+0x44>
					}
				}
			}
			taskEXIT_CRITICAL();
		}
	}
    1816:	df 91       	pop	r29
    1818:	cf 91       	pop	r28
    181a:	1f 91       	pop	r17
    181c:	0f 91       	pop	r16
    181e:	08 95       	ret

00001820 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    1820:	ef 92       	push	r14
    1822:	ff 92       	push	r15
    1824:	0f 93       	push	r16
    1826:	1f 93       	push	r17
    1828:	cf 93       	push	r28
    182a:	df 93       	push	r29
    182c:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    182e:	0f b6       	in	r0, 0x3f	; 63
    1830:	f8 94       	cli
    1832:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    1834:	80 91 88 06 	lds	r24, 0x0688
    1838:	90 91 89 06 	lds	r25, 0x0689
    183c:	08 17       	cp	r16, r24
    183e:	19 07       	cpc	r17, r25
    1840:	19 f4       	brne	.+6      	; 0x1848 <vTaskSuspend+0x28>
    1842:	00 e0       	ldi	r16, 0x00	; 0
    1844:	10 e0       	ldi	r17, 0x00	; 0
    1846:	03 c0       	rjmp	.+6      	; 0x184e <vTaskSuspend+0x2e>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    1848:	01 15       	cp	r16, r1
    184a:	11 05       	cpc	r17, r1
    184c:	29 f4       	brne	.+10     	; 0x1858 <vTaskSuspend+0x38>
    184e:	c0 91 88 06 	lds	r28, 0x0688
    1852:	d0 91 89 06 	lds	r29, 0x0689
    1856:	01 c0       	rjmp	.+2      	; 0x185a <vTaskSuspend+0x3a>
    1858:	e8 01       	movw	r28, r16

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    185a:	32 e0       	ldi	r19, 0x02	; 2
    185c:	e3 2e       	mov	r14, r19
    185e:	f1 2c       	mov	r15, r1
    1860:	ec 0e       	add	r14, r28
    1862:	fd 1e       	adc	r15, r29
    1864:	c7 01       	movw	r24, r14
    1866:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    186a:	8c 89       	ldd	r24, Y+20	; 0x14
    186c:	9d 89       	ldd	r25, Y+21	; 0x15
    186e:	89 2b       	or	r24, r25
    1870:	21 f0       	breq	.+8      	; 0x187a <vTaskSuspend+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1872:	ce 01       	movw	r24, r28
    1874:	0c 96       	adiw	r24, 0x0c	; 12
    1876:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    187a:	82 ee       	ldi	r24, 0xE2	; 226
    187c:	96 e0       	ldi	r25, 0x06	; 6
    187e:	b7 01       	movw	r22, r14
    1880:	0e 94 53 04 	call	0x8a6	; 0x8a6 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    1884:	0f 90       	pop	r0
    1886:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
    1888:	01 2b       	or	r16, r17
    188a:	a1 f4       	brne	.+40     	; 0x18b4 <vTaskSuspend+0x94>
		{
			if( xSchedulerRunning != pdFALSE )
    188c:	80 91 92 06 	lds	r24, 0x0692
    1890:	88 23       	and	r24, r24
    1892:	19 f0       	breq	.+6      	; 0x189a <vTaskSuspend+0x7a>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
    1894:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vPortYield>
    1898:	0d c0       	rjmp	.+26     	; 0x18b4 <vTaskSuspend+0x94>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    189a:	90 91 e2 06 	lds	r25, 0x06E2
    189e:	80 91 91 06 	lds	r24, 0x0691
    18a2:	98 17       	cp	r25, r24
    18a4:	29 f4       	brne	.+10     	; 0x18b0 <vTaskSuspend+0x90>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    18a6:	10 92 89 06 	sts	0x0689, r1
    18aa:	10 92 88 06 	sts	0x0688, r1
    18ae:	02 c0       	rjmp	.+4      	; 0x18b4 <vTaskSuspend+0x94>
				}
				else
				{
					vTaskSwitchContext();
    18b0:	0e 94 29 09 	call	0x1252	; 0x1252 <vTaskSwitchContext>
				}
			}
		}
	}
    18b4:	df 91       	pop	r29
    18b6:	cf 91       	pop	r28
    18b8:	1f 91       	pop	r17
    18ba:	0f 91       	pop	r16
    18bc:	ff 90       	pop	r15
    18be:	ef 90       	pop	r14
    18c0:	08 95       	ret

000018c2 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    18c2:	0f 93       	push	r16
    18c4:	1f 93       	push	r17
    18c6:	cf 93       	push	r28
    18c8:	df 93       	push	r29
    18ca:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    18cc:	00 97       	sbiw	r24, 0x00	; 0
    18ce:	c9 f0       	breq	.+50     	; 0x1902 <vTaskDelay+0x40>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    18d0:	80 91 8e 06 	lds	r24, 0x068E
    18d4:	8f 5f       	subi	r24, 0xFF	; 255
    18d6:	80 93 8e 06 	sts	0x068E, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    18da:	00 91 8c 06 	lds	r16, 0x068C
    18de:	10 91 8d 06 	lds	r17, 0x068D

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    18e2:	80 91 88 06 	lds	r24, 0x0688
    18e6:	90 91 89 06 	lds	r25, 0x0689
    18ea:	02 96       	adiw	r24, 0x02	; 2
    18ec:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    18f0:	ce 01       	movw	r24, r28
    18f2:	80 0f       	add	r24, r16
    18f4:	91 1f       	adc	r25, r17
    18f6:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    18fa:	0e 94 4c 0b 	call	0x1698	; 0x1698 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    18fe:	88 23       	and	r24, r24
    1900:	11 f4       	brne	.+4      	; 0x1906 <vTaskDelay+0x44>
		{
			portYIELD_WITHIN_API();
    1902:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vPortYield>
		}
	}
    1906:	df 91       	pop	r29
    1908:	cf 91       	pop	r28
    190a:	1f 91       	pop	r17
    190c:	0f 91       	pop	r16
    190e:	08 95       	ret

00001910 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1910:	cf 93       	push	r28
    1912:	df 93       	push	r29
    1914:	fc 01       	movw	r30, r24
    1916:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1918:	80 91 8e 06 	lds	r24, 0x068E
    191c:	8f 5f       	subi	r24, 0xFF	; 255
    191e:	80 93 8e 06 	sts	0x068E, r24
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1922:	20 81       	ld	r18, Z
    1924:	31 81       	ldd	r19, Z+1	; 0x01
    1926:	c2 0f       	add	r28, r18
    1928:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    192a:	80 91 8c 06 	lds	r24, 0x068C
    192e:	90 91 8d 06 	lds	r25, 0x068D
    1932:	82 17       	cp	r24, r18
    1934:	93 07       	cpc	r25, r19
    1936:	28 f4       	brcc	.+10     	; 0x1942 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1938:	c2 17       	cp	r28, r18
    193a:	d3 07       	cpc	r29, r19
    193c:	28 f0       	brcs	.+10     	; 0x1948 <vTaskDelayUntil+0x38>
    193e:	20 e0       	ldi	r18, 0x00	; 0
    1940:	0c c0       	rjmp	.+24     	; 0x195a <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1942:	c2 17       	cp	r28, r18
    1944:	d3 07       	cpc	r29, r19
    1946:	40 f0       	brcs	.+16     	; 0x1958 <vTaskDelayUntil+0x48>
    1948:	80 91 8c 06 	lds	r24, 0x068C
    194c:	90 91 8d 06 	lds	r25, 0x068D
    1950:	20 e0       	ldi	r18, 0x00	; 0
    1952:	8c 17       	cp	r24, r28
    1954:	9d 07       	cpc	r25, r29
    1956:	08 f4       	brcc	.+2      	; 0x195a <vTaskDelayUntil+0x4a>
    1958:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    195a:	d1 83       	std	Z+1, r29	; 0x01
    195c:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    195e:	22 23       	and	r18, r18
    1960:	51 f0       	breq	.+20     	; 0x1976 <vTaskDelayUntil+0x66>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1962:	80 91 88 06 	lds	r24, 0x0688
    1966:	90 91 89 06 	lds	r25, 0x0689
    196a:	02 96       	adiw	r24, 0x02	; 2
    196c:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1970:	ce 01       	movw	r24, r28
    1972:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1976:	0e 94 4c 0b 	call	0x1698	; 0x1698 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    197a:	88 23       	and	r24, r24
    197c:	11 f4       	brne	.+4      	; 0x1982 <vTaskDelayUntil+0x72>
		{
			portYIELD_WITHIN_API();
    197e:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vPortYield>
		}
	}
    1982:	df 91       	pop	r29
    1984:	cf 91       	pop	r28
    1986:	08 95       	ret

00001988 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1988:	ef 92       	push	r14
    198a:	ff 92       	push	r15
    198c:	0f 93       	push	r16
    198e:	1f 93       	push	r17
    1990:	cf 93       	push	r28
    1992:	df 93       	push	r29
    1994:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1996:	0f b6       	in	r0, 0x3f	; 63
    1998:	f8 94       	cli
    199a:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    199c:	80 91 88 06 	lds	r24, 0x0688
    19a0:	90 91 89 06 	lds	r25, 0x0689
    19a4:	08 17       	cp	r16, r24
    19a6:	19 07       	cpc	r17, r25
    19a8:	19 f4       	brne	.+6      	; 0x19b0 <vTaskDelete+0x28>
    19aa:	00 e0       	ldi	r16, 0x00	; 0
    19ac:	10 e0       	ldi	r17, 0x00	; 0
    19ae:	03 c0       	rjmp	.+6      	; 0x19b6 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    19b0:	01 15       	cp	r16, r1
    19b2:	11 05       	cpc	r17, r1
    19b4:	29 f4       	brne	.+10     	; 0x19c0 <vTaskDelete+0x38>
    19b6:	c0 91 88 06 	lds	r28, 0x0688
    19ba:	d0 91 89 06 	lds	r29, 0x0689
    19be:	01 c0       	rjmp	.+2      	; 0x19c2 <vTaskDelete+0x3a>
    19c0:	e8 01       	movw	r28, r16

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    19c2:	42 e0       	ldi	r20, 0x02	; 2
    19c4:	e4 2e       	mov	r14, r20
    19c6:	f1 2c       	mov	r15, r1
    19c8:	ec 0e       	add	r14, r28
    19ca:	fd 1e       	adc	r15, r29
    19cc:	c7 01       	movw	r24, r14
    19ce:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    19d2:	8c 89       	ldd	r24, Y+20	; 0x14
    19d4:	9d 89       	ldd	r25, Y+21	; 0x15
    19d6:	89 2b       	or	r24, r25
    19d8:	21 f0       	breq	.+8      	; 0x19e2 <vTaskDelete+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    19da:	ce 01       	movw	r24, r28
    19dc:	0c 96       	adiw	r24, 0x0c	; 12
    19de:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    19e2:	89 ed       	ldi	r24, 0xD9	; 217
    19e4:	96 e0       	ldi	r25, 0x06	; 6
    19e6:	b7 01       	movw	r22, r14
    19e8:	0e 94 53 04 	call	0x8a6	; 0x8a6 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    19ec:	80 91 93 06 	lds	r24, 0x0693
    19f0:	8f 5f       	subi	r24, 0xFF	; 255
    19f2:	80 93 93 06 	sts	0x0693, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    19f6:	80 91 94 06 	lds	r24, 0x0694
    19fa:	8f 5f       	subi	r24, 0xFF	; 255
    19fc:	80 93 94 06 	sts	0x0694, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1a00:	0f 90       	pop	r0
    1a02:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1a04:	80 91 92 06 	lds	r24, 0x0692
    1a08:	88 23       	and	r24, r24
    1a0a:	21 f0       	breq	.+8      	; 0x1a14 <vTaskDelete+0x8c>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1a0c:	01 2b       	or	r16, r17
    1a0e:	11 f4       	brne	.+4      	; 0x1a14 <vTaskDelete+0x8c>
			{
				portYIELD_WITHIN_API();
    1a10:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vPortYield>
			}
		}
	}
    1a14:	df 91       	pop	r29
    1a16:	cf 91       	pop	r28
    1a18:	1f 91       	pop	r17
    1a1a:	0f 91       	pop	r16
    1a1c:	ff 90       	pop	r15
    1a1e:	ef 90       	pop	r14
    1a20:	08 95       	ret

00001a22 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1a22:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1a24:	10 92 92 06 	sts	0x0692, r1
	vPortEndScheduler();
    1a28:	0e 94 56 05 	call	0xaac	; 0xaac <vPortEndScheduler>
}
    1a2c:	08 95       	ret

00001a2e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    1a2e:	0f 93       	push	r16
    1a30:	1f 93       	push	r17
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    1a32:	80 91 93 06 	lds	r24, 0x0693
    1a36:	88 23       	and	r24, r24
    1a38:	e1 f3       	breq	.-8      	; 0x1a32 <prvIdleTask+0x4>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1a3a:	80 91 8e 06 	lds	r24, 0x068E
    1a3e:	8f 5f       	subi	r24, 0xFF	; 255
    1a40:	80 93 8e 06 	sts	0x068E, r24
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1a44:	10 91 d9 06 	lds	r17, 0x06D9
			xTaskResumeAll();
    1a48:	0e 94 4c 0b 	call	0x1698	; 0x1698 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1a4c:	11 23       	and	r17, r17
    1a4e:	89 f3       	breq	.-30     	; 0x1a32 <prvIdleTask+0x4>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    1a50:	0f b6       	in	r0, 0x3f	; 63
    1a52:	f8 94       	cli
    1a54:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    1a56:	e0 91 de 06 	lds	r30, 0x06DE
    1a5a:	f0 91 df 06 	lds	r31, 0x06DF
    1a5e:	06 81       	ldd	r16, Z+6	; 0x06
    1a60:	17 81       	ldd	r17, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    1a62:	c8 01       	movw	r24, r16
    1a64:	02 96       	adiw	r24, 0x02	; 2
    1a66:	0e 94 b1 04 	call	0x962	; 0x962 <vListRemove>
					--uxCurrentNumberOfTasks;
    1a6a:	80 91 91 06 	lds	r24, 0x0691
    1a6e:	81 50       	subi	r24, 0x01	; 1
    1a70:	80 93 91 06 	sts	0x0691, r24
					--uxTasksDeleted;
    1a74:	80 91 93 06 	lds	r24, 0x0693
    1a78:	81 50       	subi	r24, 0x01	; 1
    1a7a:	80 93 93 06 	sts	0x0693, r24
				}
				taskEXIT_CRITICAL();
    1a7e:	0f 90       	pop	r0
    1a80:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    1a82:	f8 01       	movw	r30, r16
    1a84:	87 89       	ldd	r24, Z+23	; 0x17
    1a86:	90 8d       	ldd	r25, Z+24	; 0x18
    1a88:	0e 94 08 04 	call	0x810	; 0x810 <vPortFree>
		vPortFree( pxTCB );
    1a8c:	c8 01       	movw	r24, r16
    1a8e:	0e 94 08 04 	call	0x810	; 0x810 <vPortFree>
    1a92:	cf cf       	rjmp	.-98     	; 0x1a32 <prvIdleTask+0x4>

00001a94 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1a94:	2f 92       	push	r2
    1a96:	3f 92       	push	r3
    1a98:	5f 92       	push	r5
    1a9a:	6f 92       	push	r6
    1a9c:	7f 92       	push	r7
    1a9e:	8f 92       	push	r8
    1aa0:	9f 92       	push	r9
    1aa2:	af 92       	push	r10
    1aa4:	bf 92       	push	r11
    1aa6:	cf 92       	push	r12
    1aa8:	df 92       	push	r13
    1aaa:	ef 92       	push	r14
    1aac:	ff 92       	push	r15
    1aae:	0f 93       	push	r16
    1ab0:	1f 93       	push	r17
    1ab2:	df 93       	push	r29
    1ab4:	cf 93       	push	r28
    1ab6:	00 d0       	rcall	.+0      	; 0x1ab8 <xTaskGenericCreate+0x24>
    1ab8:	00 d0       	rcall	.+0      	; 0x1aba <xTaskGenericCreate+0x26>
    1aba:	cd b7       	in	r28, 0x3d	; 61
    1abc:	de b7       	in	r29, 0x3e	; 62
    1abe:	9a 83       	std	Y+2, r25	; 0x02
    1ac0:	89 83       	std	Y+1, r24	; 0x01
    1ac2:	4b 01       	movw	r8, r22
    1ac4:	5a 01       	movw	r10, r20
    1ac6:	19 01       	movw	r2, r18
    1ac8:	50 2e       	mov	r5, r16
    1aca:	37 01       	movw	r6, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    1acc:	81 e2       	ldi	r24, 0x21	; 33
    1ace:	90 e0       	ldi	r25, 0x00	; 0
    1ad0:	0e 94 18 04 	call	0x830	; 0x830 <pvPortMalloc>
    1ad4:	8b 83       	std	Y+3, r24	; 0x03
    1ad6:	9c 83       	std	Y+4, r25	; 0x04

	if( pxNewTCB != NULL )
    1ad8:	8b 81       	ldd	r24, Y+3	; 0x03
    1ada:	9c 81       	ldd	r25, Y+4	; 0x04
    1adc:	89 2b       	or	r24, r25
    1ade:	89 f0       	breq	.+34     	; 0x1b02 <xTaskGenericCreate+0x6e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1ae0:	c1 14       	cp	r12, r1
    1ae2:	d1 04       	cpc	r13, r1
    1ae4:	21 f4       	brne	.+8      	; 0x1aee <xTaskGenericCreate+0x5a>
    1ae6:	c5 01       	movw	r24, r10
    1ae8:	0e 94 18 04 	call	0x830	; 0x830 <pvPortMalloc>
    1aec:	6c 01       	movw	r12, r24
    1aee:	eb 81       	ldd	r30, Y+3	; 0x03
    1af0:	fc 81       	ldd	r31, Y+4	; 0x04
    1af2:	d0 8e       	std	Z+24, r13	; 0x18
    1af4:	c7 8a       	std	Z+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    1af6:	c1 14       	cp	r12, r1
    1af8:	d1 04       	cpc	r13, r1
    1afa:	29 f4       	brne	.+10     	; 0x1b06 <xTaskGenericCreate+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1afc:	cf 01       	movw	r24, r30
    1afe:	0e 94 08 04 	call	0x810	; 0x810 <vPortFree>
    1b02:	8f ef       	ldi	r24, 0xFF	; 255
    1b04:	da c0       	rjmp	.+436    	; 0x1cba <xTaskGenericCreate+0x226>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    1b06:	c6 01       	movw	r24, r12
    1b08:	65 ea       	ldi	r22, 0xA5	; 165
    1b0a:	70 e0       	ldi	r23, 0x00	; 0
    1b0c:	a5 01       	movw	r20, r10
    1b0e:	0e 94 a8 10 	call	0x2150	; 0x2150 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1b12:	08 94       	sec
    1b14:	a1 08       	sbc	r10, r1
    1b16:	b1 08       	sbc	r11, r1
    1b18:	eb 81       	ldd	r30, Y+3	; 0x03
    1b1a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b1c:	e7 88       	ldd	r14, Z+23	; 0x17
    1b1e:	f0 8c       	ldd	r15, Z+24	; 0x18
    1b20:	ea 0c       	add	r14, r10
    1b22:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1b24:	cf 01       	movw	r24, r30
    1b26:	49 96       	adiw	r24, 0x19	; 25
    1b28:	b4 01       	movw	r22, r8
    1b2a:	48 e0       	ldi	r20, 0x08	; 8
    1b2c:	50 e0       	ldi	r21, 0x00	; 0
    1b2e:	0e 94 af 10 	call	0x215e	; 0x215e <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    1b32:	eb 81       	ldd	r30, Y+3	; 0x03
    1b34:	fc 81       	ldd	r31, Y+4	; 0x04
    1b36:	10 a2       	std	Z+32, r1	; 0x20
    1b38:	05 2d       	mov	r16, r5
    1b3a:	f3 e0       	ldi	r31, 0x03	; 3
    1b3c:	f5 15       	cp	r31, r5
    1b3e:	08 f4       	brcc	.+2      	; 0x1b42 <xTaskGenericCreate+0xae>
    1b40:	03 e0       	ldi	r16, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    1b42:	eb 81       	ldd	r30, Y+3	; 0x03
    1b44:	fc 81       	ldd	r31, Y+4	; 0x04
    1b46:	06 8b       	std	Z+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1b48:	62 e0       	ldi	r22, 0x02	; 2
    1b4a:	c6 2e       	mov	r12, r22
    1b4c:	d1 2c       	mov	r13, r1
    1b4e:	ce 0e       	add	r12, r30
    1b50:	df 1e       	adc	r13, r31
    1b52:	c6 01       	movw	r24, r12
    1b54:	0e 94 4f 04 	call	0x89e	; 0x89e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1b58:	8b 81       	ldd	r24, Y+3	; 0x03
    1b5a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b5c:	0c 96       	adiw	r24, 0x0c	; 12
    1b5e:	0e 94 4f 04 	call	0x89e	; 0x89e <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1b62:	8b 81       	ldd	r24, Y+3	; 0x03
    1b64:	9c 81       	ldd	r25, Y+4	; 0x04
    1b66:	fc 01       	movw	r30, r24
    1b68:	91 87       	std	Z+9, r25	; 0x09
    1b6a:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1b6c:	84 e0       	ldi	r24, 0x04	; 4
    1b6e:	90 e0       	ldi	r25, 0x00	; 0
    1b70:	80 1b       	sub	r24, r16
    1b72:	91 09       	sbc	r25, r1
    1b74:	95 87       	std	Z+13, r25	; 0x0d
    1b76:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1b78:	f3 8b       	std	Z+19, r31	; 0x13
    1b7a:	e2 8b       	std	Z+18, r30	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1b7c:	c7 01       	movw	r24, r14
    1b7e:	69 81       	ldd	r22, Y+1	; 0x01
    1b80:	7a 81       	ldd	r23, Y+2	; 0x02
    1b82:	a1 01       	movw	r20, r2
    1b84:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <pxPortInitialiseStack>
    1b88:	eb 81       	ldd	r30, Y+3	; 0x03
    1b8a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b8c:	91 83       	std	Z+1, r25	; 0x01
    1b8e:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    1b90:	61 14       	cp	r6, r1
    1b92:	71 04       	cpc	r7, r1
    1b94:	21 f0       	breq	.+8      	; 0x1b9e <xTaskGenericCreate+0x10a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1b96:	cf 01       	movw	r24, r30
    1b98:	f3 01       	movw	r30, r6
    1b9a:	91 83       	std	Z+1, r25	; 0x01
    1b9c:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1b9e:	0f b6       	in	r0, 0x3f	; 63
    1ba0:	f8 94       	cli
    1ba2:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1ba4:	80 91 91 06 	lds	r24, 0x0691
    1ba8:	8f 5f       	subi	r24, 0xFF	; 255
    1baa:	80 93 91 06 	sts	0x0691, r24
			if( pxCurrentTCB == NULL )
    1bae:	80 91 88 06 	lds	r24, 0x0688
    1bb2:	90 91 89 06 	lds	r25, 0x0689
    1bb6:	89 2b       	or	r24, r25
    1bb8:	e1 f5       	brne	.+120    	; 0x1c32 <xTaskGenericCreate+0x19e>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1bba:	eb 81       	ldd	r30, Y+3	; 0x03
    1bbc:	fc 81       	ldd	r31, Y+4	; 0x04
    1bbe:	f0 93 89 06 	sts	0x0689, r31
    1bc2:	e0 93 88 06 	sts	0x0688, r30

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1bc6:	80 91 91 06 	lds	r24, 0x0691
    1bca:	81 30       	cpi	r24, 0x01	; 1
    1bcc:	09 f0       	breq	.+2      	; 0x1bd0 <xTaskGenericCreate+0x13c>
    1bce:	42 c0       	rjmp	.+132    	; 0x1c54 <xTaskGenericCreate+0x1c0>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    1bd0:	86 e9       	ldi	r24, 0x96	; 150
    1bd2:	96 e0       	ldi	r25, 0x06	; 6
    1bd4:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>
    1bd8:	8f e9       	ldi	r24, 0x9F	; 159
    1bda:	96 e0       	ldi	r25, 0x06	; 6
    1bdc:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>
    1be0:	88 ea       	ldi	r24, 0xA8	; 168
    1be2:	96 e0       	ldi	r25, 0x06	; 6
    1be4:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>
    1be8:	81 eb       	ldi	r24, 0xB1	; 177
    1bea:	96 e0       	ldi	r25, 0x06	; 6
    1bec:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    1bf0:	5a eb       	ldi	r21, 0xBA	; 186
    1bf2:	e5 2e       	mov	r14, r21
    1bf4:	56 e0       	ldi	r21, 0x06	; 6
    1bf6:	f5 2e       	mov	r15, r21
    1bf8:	c7 01       	movw	r24, r14
    1bfa:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1bfe:	03 ec       	ldi	r16, 0xC3	; 195
    1c00:	16 e0       	ldi	r17, 0x06	; 6
    1c02:	c8 01       	movw	r24, r16
    1c04:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    1c08:	80 ed       	ldi	r24, 0xD0	; 208
    1c0a:	96 e0       	ldi	r25, 0x06	; 6
    1c0c:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    1c10:	89 ed       	ldi	r24, 0xD9	; 217
    1c12:	96 e0       	ldi	r25, 0x06	; 6
    1c14:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    1c18:	82 ee       	ldi	r24, 0xE2	; 226
    1c1a:	96 e0       	ldi	r25, 0x06	; 6
    1c1c:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1c20:	f0 92 cd 06 	sts	0x06CD, r15
    1c24:	e0 92 cc 06 	sts	0x06CC, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1c28:	10 93 cf 06 	sts	0x06CF, r17
    1c2c:	00 93 ce 06 	sts	0x06CE, r16
    1c30:	11 c0       	rjmp	.+34     	; 0x1c54 <xTaskGenericCreate+0x1c0>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1c32:	80 91 92 06 	lds	r24, 0x0692
    1c36:	88 23       	and	r24, r24
    1c38:	69 f4       	brne	.+26     	; 0x1c54 <xTaskGenericCreate+0x1c0>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1c3a:	e0 91 88 06 	lds	r30, 0x0688
    1c3e:	f0 91 89 06 	lds	r31, 0x0689
    1c42:	86 89       	ldd	r24, Z+22	; 0x16
    1c44:	58 16       	cp	r5, r24
    1c46:	30 f0       	brcs	.+12     	; 0x1c54 <xTaskGenericCreate+0x1c0>
					{
						pxCurrentTCB = pxNewTCB;
    1c48:	8b 81       	ldd	r24, Y+3	; 0x03
    1c4a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c4c:	90 93 89 06 	sts	0x0689, r25
    1c50:	80 93 88 06 	sts	0x0688, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1c54:	eb 81       	ldd	r30, Y+3	; 0x03
    1c56:	fc 81       	ldd	r31, Y+4	; 0x04
    1c58:	96 89       	ldd	r25, Z+22	; 0x16
    1c5a:	80 91 95 06 	lds	r24, 0x0695
    1c5e:	89 17       	cp	r24, r25
    1c60:	10 f4       	brcc	.+4      	; 0x1c66 <xTaskGenericCreate+0x1d2>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1c62:	90 93 95 06 	sts	0x0695, r25
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1c66:	80 91 94 06 	lds	r24, 0x0694
    1c6a:	8f 5f       	subi	r24, 0xFF	; 255
    1c6c:	80 93 94 06 	sts	0x0694, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1c70:	eb 81       	ldd	r30, Y+3	; 0x03
    1c72:	fc 81       	ldd	r31, Y+4	; 0x04
    1c74:	96 89       	ldd	r25, Z+22	; 0x16
    1c76:	80 91 8f 06 	lds	r24, 0x068F
    1c7a:	89 17       	cp	r24, r25
    1c7c:	10 f4       	brcc	.+4      	; 0x1c82 <xTaskGenericCreate+0x1ee>
    1c7e:	90 93 8f 06 	sts	0x068F, r25
    1c82:	eb 81       	ldd	r30, Y+3	; 0x03
    1c84:	fc 81       	ldd	r31, Y+4	; 0x04
    1c86:	86 89       	ldd	r24, Z+22	; 0x16
    1c88:	29 e0       	ldi	r18, 0x09	; 9
    1c8a:	82 9f       	mul	r24, r18
    1c8c:	c0 01       	movw	r24, r0
    1c8e:	11 24       	eor	r1, r1
    1c90:	8a 56       	subi	r24, 0x6A	; 106
    1c92:	99 4f       	sbci	r25, 0xF9	; 249
    1c94:	b6 01       	movw	r22, r12
    1c96:	0e 94 53 04 	call	0x8a6	; 0x8a6 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1c9a:	0f 90       	pop	r0
    1c9c:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1c9e:	80 91 92 06 	lds	r24, 0x0692
    1ca2:	88 23       	and	r24, r24
    1ca4:	49 f0       	breq	.+18     	; 0x1cb8 <xTaskGenericCreate+0x224>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1ca6:	e0 91 88 06 	lds	r30, 0x0688
    1caa:	f0 91 89 06 	lds	r31, 0x0689
    1cae:	86 89       	ldd	r24, Z+22	; 0x16
    1cb0:	85 15       	cp	r24, r5
    1cb2:	10 f4       	brcc	.+4      	; 0x1cb8 <xTaskGenericCreate+0x224>
			{
				portYIELD_WITHIN_API();
    1cb4:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vPortYield>
    1cb8:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    1cba:	0f 90       	pop	r0
    1cbc:	0f 90       	pop	r0
    1cbe:	0f 90       	pop	r0
    1cc0:	0f 90       	pop	r0
    1cc2:	cf 91       	pop	r28
    1cc4:	df 91       	pop	r29
    1cc6:	1f 91       	pop	r17
    1cc8:	0f 91       	pop	r16
    1cca:	ff 90       	pop	r15
    1ccc:	ef 90       	pop	r14
    1cce:	df 90       	pop	r13
    1cd0:	cf 90       	pop	r12
    1cd2:	bf 90       	pop	r11
    1cd4:	af 90       	pop	r10
    1cd6:	9f 90       	pop	r9
    1cd8:	8f 90       	pop	r8
    1cda:	7f 90       	pop	r7
    1cdc:	6f 90       	pop	r6
    1cde:	5f 90       	pop	r5
    1ce0:	3f 90       	pop	r3
    1ce2:	2f 90       	pop	r2
    1ce4:	08 95       	ret

00001ce6 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1ce6:	af 92       	push	r10
    1ce8:	bf 92       	push	r11
    1cea:	cf 92       	push	r12
    1cec:	df 92       	push	r13
    1cee:	ef 92       	push	r14
    1cf0:	ff 92       	push	r15
    1cf2:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1cf4:	87 e1       	ldi	r24, 0x17	; 23
    1cf6:	9d e0       	ldi	r25, 0x0D	; 13
    1cf8:	60 e6       	ldi	r22, 0x60	; 96
    1cfa:	70 e0       	ldi	r23, 0x00	; 0
    1cfc:	46 e4       	ldi	r20, 0x46	; 70
    1cfe:	50 e0       	ldi	r21, 0x00	; 0
    1d00:	20 e0       	ldi	r18, 0x00	; 0
    1d02:	30 e0       	ldi	r19, 0x00	; 0
    1d04:	00 e0       	ldi	r16, 0x00	; 0
    1d06:	ee 24       	eor	r14, r14
    1d08:	ff 24       	eor	r15, r15
    1d0a:	cc 24       	eor	r12, r12
    1d0c:	dd 24       	eor	r13, r13
    1d0e:	aa 24       	eor	r10, r10
    1d10:	bb 24       	eor	r11, r11
    1d12:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1d16:	81 30       	cpi	r24, 0x01	; 1
    1d18:	49 f4       	brne	.+18     	; 0x1d2c <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1d1a:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1d1c:	80 93 92 06 	sts	0x0692, r24
		xTickCount = ( portTickType ) 0U;
    1d20:	10 92 8d 06 	sts	0x068D, r1
    1d24:	10 92 8c 06 	sts	0x068C, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1d28:	0e 94 21 05 	call	0xa42	; 0xa42 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1d2c:	0f 91       	pop	r16
    1d2e:	ff 90       	pop	r15
    1d30:	ef 90       	pop	r14
    1d32:	df 90       	pop	r13
    1d34:	cf 90       	pop	r12
    1d36:	bf 90       	pop	r11
    1d38:	af 90       	pop	r10
    1d3a:	08 95       	ret

00001d3c <EAST_WEST_GREENDisable>:
}


void EAST_WEST_GREENDisable()
{
	vSET_PORT_OUTPUT_VALUE(PORT_A,0x00);
    1d3c:	80 e0       	ldi	r24, 0x00	; 0
    1d3e:	60 e0       	ldi	r22, 0x00	; 0
    1d40:	0e 94 39 02 	call	0x472	; 0x472 <vSET_PORT_OUTPUT_VALUE>
}
    1d44:	08 95       	ret

00001d46 <EAST_WEST_GREENEnable>:
	vSET_PORT_OUTPUT_VALUE(PORT_B,0x00);
}

void EAST_WEST_GREENEnable()
{
	vSET_PORT_OUTPUT_VALUE(PORT_A,0x0f);
    1d46:	80 e0       	ldi	r24, 0x00	; 0
    1d48:	6f e0       	ldi	r22, 0x0F	; 15
    1d4a:	0e 94 39 02 	call	0x472	; 0x472 <vSET_PORT_OUTPUT_VALUE>
}
    1d4e:	08 95       	ret

00001d50 <Yellow_Disable>:
	vSET_PORT_OUTPUT_VALUE(PORT_B,0x0f);
}

void Yellow_Disable()
{
	vSET_PORT_OUTPUT_VALUE(PORT_B,0x00);
    1d50:	81 e0       	ldi	r24, 0x01	; 1
    1d52:	60 e0       	ldi	r22, 0x00	; 0
    1d54:	0e 94 39 02 	call	0x472	; 0x472 <vSET_PORT_OUTPUT_VALUE>
}
    1d58:	08 95       	ret

00001d5a <Yellow_Enable>:
	vSET_PORT_OUTPUT_VALUE(PORT_C,0x00);
}

void Yellow_Enable()
{
	vSET_PORT_OUTPUT_VALUE(PORT_B,0x0f);
    1d5a:	81 e0       	ldi	r24, 0x01	; 1
    1d5c:	6f e0       	ldi	r22, 0x0F	; 15
    1d5e:	0e 94 39 02 	call	0x472	; 0x472 <vSET_PORT_OUTPUT_VALUE>
}
    1d62:	08 95       	ret

00001d64 <North_South_GreenDisable>:
	vSET_PORT_OUTPUT_VALUE(PORT_C,0x0f);
}

void North_South_GreenDisable()
{
	vSET_PORT_OUTPUT_VALUE(PORT_C,0x00);
    1d64:	82 e0       	ldi	r24, 0x02	; 2
    1d66:	60 e0       	ldi	r22, 0x00	; 0
    1d68:	0e 94 39 02 	call	0x472	; 0x472 <vSET_PORT_OUTPUT_VALUE>
}
    1d6c:	08 95       	ret

00001d6e <North_South_GreenEnable>:



void North_South_GreenEnable()
{
	vSET_PORT_OUTPUT_VALUE(PORT_C,0x0f);
    1d6e:	82 e0       	ldi	r24, 0x02	; 2
    1d70:	6f e0       	ldi	r22, 0x0F	; 15
    1d72:	0e 94 39 02 	call	0x472	; 0x472 <vSET_PORT_OUTPUT_VALUE>
}
    1d76:	08 95       	ret

00001d78 <vSetUp_TrafficButton_Direction>:
}


void vSetUp_TrafficButton_Direction()
{
	vSET_PIN_DIRECTION(PORT_D,PIN_2,INPUT);
    1d78:	83 e0       	ldi	r24, 0x03	; 3
    1d7a:	62 e0       	ldi	r22, 0x02	; 2
    1d7c:	40 e0       	ldi	r20, 0x00	; 0
    1d7e:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <vSET_PIN_DIRECTION>
	vSET_PIN_DIRECTION(PORT_D,PIN_3,INPUT);
    1d82:	83 e0       	ldi	r24, 0x03	; 3
    1d84:	63 e0       	ldi	r22, 0x03	; 3
    1d86:	40 e0       	ldi	r20, 0x00	; 0
    1d88:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <vSET_PIN_DIRECTION>

	vSET_PIN_OUTPUT_VALUE(PORT_D,PIN_2,HIGH);
    1d8c:	83 e0       	ldi	r24, 0x03	; 3
    1d8e:	62 e0       	ldi	r22, 0x02	; 2
    1d90:	41 e0       	ldi	r20, 0x01	; 1
    1d92:	0e 94 5f 01 	call	0x2be	; 0x2be <vSET_PIN_OUTPUT_VALUE>
	vSET_PIN_OUTPUT_VALUE(PORT_D,PIN_3,HIGH);
    1d96:	83 e0       	ldi	r24, 0x03	; 3
    1d98:	63 e0       	ldi	r22, 0x03	; 3
    1d9a:	41 e0       	ldi	r20, 0x01	; 1
    1d9c:	0e 94 5f 01 	call	0x2be	; 0x2be <vSET_PIN_OUTPUT_VALUE>

	EXTI_SELECT_MODE(EXTI_0,FALLING_E);
    1da0:	80 e0       	ldi	r24, 0x00	; 0
    1da2:	62 e0       	ldi	r22, 0x02	; 2
    1da4:	0e 94 51 00 	call	0xa2	; 0xa2 <EXTI_SELECT_MODE>
	EXTI_SELECT_MODE(EXTI_1,FALLING_E);
    1da8:	81 e0       	ldi	r24, 0x01	; 1
    1daa:	62 e0       	ldi	r22, 0x02	; 2
    1dac:	0e 94 51 00 	call	0xa2	; 0xa2 <EXTI_SELECT_MODE>

	EXTI_SELECT_INTERRUBT_ENABLE(EXTI_0);
    1db0:	80 e0       	ldi	r24, 0x00	; 0
    1db2:	0e 94 a0 00 	call	0x140	; 0x140 <EXTI_SELECT_INTERRUBT_ENABLE>
	EXTI_SELECT_INTERRUBT_ENABLE(EXTI_1);
    1db6:	81 e0       	ldi	r24, 0x01	; 1
    1db8:	0e 94 a0 00 	call	0x140	; 0x140 <EXTI_SELECT_INTERRUBT_ENABLE>

	GI_ENABLE();
    1dbc:	0e 94 49 00 	call	0x92	; 0x92 <GI_ENABLE>

}
    1dc0:	08 95       	ret

00001dc2 <vSetUp_TrafficLed_Direction>:
#include "T_Led.h"

void vSetUp_TrafficLed_Direction()
{
	// MAKE ALL LED AS OUTPUT DIRECTIONS
	vSET_PORT_DIRECTION(PORT_A,0x0f);
    1dc2:	80 e0       	ldi	r24, 0x00	; 0
    1dc4:	6f e0       	ldi	r22, 0x0F	; 15
    1dc6:	0e 94 28 02 	call	0x450	; 0x450 <vSET_PORT_DIRECTION>
	vSET_PORT_DIRECTION(PORT_B,0x0f);
    1dca:	81 e0       	ldi	r24, 0x01	; 1
    1dcc:	6f e0       	ldi	r22, 0x0F	; 15
    1dce:	0e 94 28 02 	call	0x450	; 0x450 <vSET_PORT_DIRECTION>
	vSET_PORT_DIRECTION(PORT_C,0x0f);
    1dd2:	82 e0       	ldi	r24, 0x02	; 2
    1dd4:	6f e0       	ldi	r22, 0x0F	; 15
    1dd6:	0e 94 28 02 	call	0x450	; 0x450 <vSET_PORT_DIRECTION>
	vSET_PIN_DIRECTION(PORT_D,PIN_4,OUTPUT);
    1dda:	83 e0       	ldi	r24, 0x03	; 3
    1ddc:	64 e0       	ldi	r22, 0x04	; 4
    1dde:	41 e0       	ldi	r20, 0x01	; 1
    1de0:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <vSET_PIN_DIRECTION>
	vSET_PIN_DIRECTION(PORT_D,PIN_5,OUTPUT);
    1de4:	83 e0       	ldi	r24, 0x03	; 3
    1de6:	65 e0       	ldi	r22, 0x05	; 5
    1de8:	41 e0       	ldi	r20, 0x01	; 1
    1dea:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <vSET_PIN_DIRECTION>
	vSET_PIN_DIRECTION(PORT_D,PIN_6,OUTPUT);
    1dee:	83 e0       	ldi	r24, 0x03	; 3
    1df0:	66 e0       	ldi	r22, 0x06	; 6
    1df2:	41 e0       	ldi	r20, 0x01	; 1
    1df4:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <vSET_PIN_DIRECTION>
	vSET_PIN_DIRECTION(PORT_D,PIN_7,OUTPUT);
    1df8:	83 e0       	ldi	r24, 0x03	; 3
    1dfa:	67 e0       	ldi	r22, 0x07	; 7
    1dfc:	41 e0       	ldi	r20, 0x01	; 1
    1dfe:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <vSET_PIN_DIRECTION>

}
    1e02:	08 95       	ret

00001e04 <__vector_2>:
}

// ISR FOR EXTERNAL INTERRUPT 2
// DETECT THE BUTTON IS PRESSED BY FALLING EDGE
void __vector_2 (void) __attribute__ ((signal,used, externally_visible)) ; \
void __vector_2 (void) {
    1e04:	1f 92       	push	r1
    1e06:	0f 92       	push	r0
    1e08:	0f b6       	in	r0, 0x3f	; 63
    1e0a:	0f 92       	push	r0
    1e0c:	11 24       	eor	r1, r1
    1e0e:	af 92       	push	r10
    1e10:	bf 92       	push	r11
    1e12:	cf 92       	push	r12
    1e14:	df 92       	push	r13
    1e16:	ef 92       	push	r14
    1e18:	ff 92       	push	r15
    1e1a:	0f 93       	push	r16
    1e1c:	2f 93       	push	r18
    1e1e:	3f 93       	push	r19
    1e20:	4f 93       	push	r20
    1e22:	5f 93       	push	r21
    1e24:	6f 93       	push	r22
    1e26:	7f 93       	push	r23
    1e28:	8f 93       	push	r24
    1e2a:	9f 93       	push	r25
    1e2c:	af 93       	push	r26
    1e2e:	bf 93       	push	r27
    1e30:	ef 93       	push	r30
    1e32:	ff 93       	push	r31
	// Set pedestrian request for East-West direction
	// create task every press on button
	xTaskCreate(&button_task2, NULL, 70, NULL, 3, NULL);
    1e34:	81 e0       	ldi	r24, 0x01	; 1
    1e36:	90 e1       	ldi	r25, 0x10	; 16
    1e38:	60 e0       	ldi	r22, 0x00	; 0
    1e3a:	70 e0       	ldi	r23, 0x00	; 0
    1e3c:	46 e4       	ldi	r20, 0x46	; 70
    1e3e:	50 e0       	ldi	r21, 0x00	; 0
    1e40:	20 e0       	ldi	r18, 0x00	; 0
    1e42:	30 e0       	ldi	r19, 0x00	; 0
    1e44:	03 e0       	ldi	r16, 0x03	; 3
    1e46:	ee 24       	eor	r14, r14
    1e48:	ff 24       	eor	r15, r15
    1e4a:	cc 24       	eor	r12, r12
    1e4c:	dd 24       	eor	r13, r13
    1e4e:	aa 24       	eor	r10, r10
    1e50:	bb 24       	eor	r11, r11
    1e52:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <xTaskGenericCreate>
}
    1e56:	ff 91       	pop	r31
    1e58:	ef 91       	pop	r30
    1e5a:	bf 91       	pop	r27
    1e5c:	af 91       	pop	r26
    1e5e:	9f 91       	pop	r25
    1e60:	8f 91       	pop	r24
    1e62:	7f 91       	pop	r23
    1e64:	6f 91       	pop	r22
    1e66:	5f 91       	pop	r21
    1e68:	4f 91       	pop	r20
    1e6a:	3f 91       	pop	r19
    1e6c:	2f 91       	pop	r18
    1e6e:	0f 91       	pop	r16
    1e70:	ff 90       	pop	r15
    1e72:	ef 90       	pop	r14
    1e74:	df 90       	pop	r13
    1e76:	cf 90       	pop	r12
    1e78:	bf 90       	pop	r11
    1e7a:	af 90       	pop	r10
    1e7c:	0f 90       	pop	r0
    1e7e:	0f be       	out	0x3f, r0	; 63
    1e80:	0f 90       	pop	r0
    1e82:	1f 90       	pop	r1
    1e84:	18 95       	reti

00001e86 <__vector_1>:


// ISR FOR EXTERNAL INTERRUPT 1
// DETECT THE BUTTON IS PRESSED BY FALLING EDGE
void __vector_1 (void) __attribute__ ((signal,used, externally_visible)) ; \
void __vector_1 (void) {
    1e86:	1f 92       	push	r1
    1e88:	0f 92       	push	r0
    1e8a:	0f b6       	in	r0, 0x3f	; 63
    1e8c:	0f 92       	push	r0
    1e8e:	11 24       	eor	r1, r1
    1e90:	af 92       	push	r10
    1e92:	bf 92       	push	r11
    1e94:	cf 92       	push	r12
    1e96:	df 92       	push	r13
    1e98:	ef 92       	push	r14
    1e9a:	ff 92       	push	r15
    1e9c:	0f 93       	push	r16
    1e9e:	2f 93       	push	r18
    1ea0:	3f 93       	push	r19
    1ea2:	4f 93       	push	r20
    1ea4:	5f 93       	push	r21
    1ea6:	6f 93       	push	r22
    1ea8:	7f 93       	push	r23
    1eaa:	8f 93       	push	r24
    1eac:	9f 93       	push	r25
    1eae:	af 93       	push	r26
    1eb0:	bf 93       	push	r27
    1eb2:	ef 93       	push	r30
    1eb4:	ff 93       	push	r31
	// Set pedestrian request for North-South direction
	// create task every press on button
	xTaskCreate(&button_task1, NULL, 70, NULL, 3, NULL);
    1eb6:	8f e4       	ldi	r24, 0x4F	; 79
    1eb8:	90 e1       	ldi	r25, 0x10	; 16
    1eba:	60 e0       	ldi	r22, 0x00	; 0
    1ebc:	70 e0       	ldi	r23, 0x00	; 0
    1ebe:	46 e4       	ldi	r20, 0x46	; 70
    1ec0:	50 e0       	ldi	r21, 0x00	; 0
    1ec2:	20 e0       	ldi	r18, 0x00	; 0
    1ec4:	30 e0       	ldi	r19, 0x00	; 0
    1ec6:	03 e0       	ldi	r16, 0x03	; 3
    1ec8:	ee 24       	eor	r14, r14
    1eca:	ff 24       	eor	r15, r15
    1ecc:	cc 24       	eor	r12, r12
    1ece:	dd 24       	eor	r13, r13
    1ed0:	aa 24       	eor	r10, r10
    1ed2:	bb 24       	eor	r11, r11
    1ed4:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <xTaskGenericCreate>
}
    1ed8:	ff 91       	pop	r31
    1eda:	ef 91       	pop	r30
    1edc:	bf 91       	pop	r27
    1ede:	af 91       	pop	r26
    1ee0:	9f 91       	pop	r25
    1ee2:	8f 91       	pop	r24
    1ee4:	7f 91       	pop	r23
    1ee6:	6f 91       	pop	r22
    1ee8:	5f 91       	pop	r21
    1eea:	4f 91       	pop	r20
    1eec:	3f 91       	pop	r19
    1eee:	2f 91       	pop	r18
    1ef0:	0f 91       	pop	r16
    1ef2:	ff 90       	pop	r15
    1ef4:	ef 90       	pop	r14
    1ef6:	df 90       	pop	r13
    1ef8:	cf 90       	pop	r12
    1efa:	bf 90       	pop	r11
    1efc:	af 90       	pop	r10
    1efe:	0f 90       	pop	r0
    1f00:	0f be       	out	0x3f, r0	; 63
    1f02:	0f 90       	pop	r0
    1f04:	1f 90       	pop	r1
    1f06:	18 95       	reti

00001f08 <main>:
		}
	}
}

int main()
{
    1f08:	af 92       	push	r10
    1f0a:	bf 92       	push	r11
    1f0c:	cf 92       	push	r12
    1f0e:	df 92       	push	r13
    1f10:	ef 92       	push	r14
    1f12:	ff 92       	push	r15
    1f14:	0f 93       	push	r16
	vSET_PIN_OUTPUT_VALUE(PORT_D,PIN_6,HIGH);
    1f16:	83 e0       	ldi	r24, 0x03	; 3
    1f18:	66 e0       	ldi	r22, 0x06	; 6
    1f1a:	41 e0       	ldi	r20, 0x01	; 1
    1f1c:	0e 94 5f 01 	call	0x2be	; 0x2be <vSET_PIN_OUTPUT_VALUE>
	vSET_PIN_OUTPUT_VALUE(PORT_D,PIN_4,HIGH);
    1f20:	83 e0       	ldi	r24, 0x03	; 3
    1f22:	64 e0       	ldi	r22, 0x04	; 4
    1f24:	41 e0       	ldi	r20, 0x01	; 1
    1f26:	0e 94 5f 01 	call	0x2be	; 0x2be <vSET_PIN_OUTPUT_VALUE>
	// SETUP ALL DIRECTION FOR LED
	vSetUp_TrafficLed_Direction();
    1f2a:	0e 94 e1 0e 	call	0x1dc2	; 0x1dc2 <vSetUp_TrafficLed_Direction>
	// SETUP ALL BUTTON DIRECTION
	vSetUp_TrafficButton_Direction();
    1f2e:	0e 94 bc 0e 	call	0x1d78	; 0x1d78 <vSetUp_TrafficButton_Direction>
	// CREATE COUNT SEMAPHOR
	LCD_KEY = xSemaphoreCreateCounting(1, 1);
    1f32:	81 e0       	ldi	r24, 0x01	; 1
    1f34:	61 e0       	ldi	r22, 0x01	; 1
    1f36:	0e 94 ef 08 	call	0x11de	; 0x11de <xQueueCreateCountingSemaphore>
    1f3a:	90 93 ec 06 	sts	0x06EC, r25
    1f3e:	80 93 eb 06 	sts	0x06EB, r24
	// CHECK CREATE DONE OR NO
	if (LCD_KEY == NULL) {
    1f42:	89 2b       	or	r24, r25
    1f44:	09 f4       	brne	.+2      	; 0x1f48 <main+0x40>
    1f46:	ff cf       	rjmp	.-2      	; 0x1f46 <main+0x3e>
		// Handle semaphore creation failure
		while (1);
	}
	// Create task
	xTaskCreate(&trafficLightControlTask, NULL, 250, NULL, 1, NULL);
    1f48:	88 eb       	ldi	r24, 0xB8	; 184
    1f4a:	9f e0       	ldi	r25, 0x0F	; 15
    1f4c:	60 e0       	ldi	r22, 0x00	; 0
    1f4e:	70 e0       	ldi	r23, 0x00	; 0
    1f50:	4a ef       	ldi	r20, 0xFA	; 250
    1f52:	50 e0       	ldi	r21, 0x00	; 0
    1f54:	20 e0       	ldi	r18, 0x00	; 0
    1f56:	30 e0       	ldi	r19, 0x00	; 0
    1f58:	01 e0       	ldi	r16, 0x01	; 1
    1f5a:	ee 24       	eor	r14, r14
    1f5c:	ff 24       	eor	r15, r15
    1f5e:	cc 24       	eor	r12, r12
    1f60:	dd 24       	eor	r13, r13
    1f62:	aa 24       	eor	r10, r10
    1f64:	bb 24       	eor	r11, r11
    1f66:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <xTaskGenericCreate>
	// Start scheduler
	vTaskStartScheduler();
    1f6a:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <vTaskStartScheduler>
    1f6e:	ff cf       	rjmp	.-2      	; 0x1f6e <main+0x66>

00001f70 <trafficLightControlTask>:


void trafficLightControlTask(void *pvParameters) {
	while (1) {
		// North-South Green
		if(Flag == 1 ){
    1f70:	80 91 67 00 	lds	r24, 0x0067
    1f74:	81 30       	cpi	r24, 0x01	; 1
    1f76:	01 f5       	brne	.+64     	; 0x1fb8 <trafficLightControlTask+0x48>
			North_South_GreenEnable();
    1f78:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <North_South_GreenEnable>
			Yellow_Disable();
    1f7c:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <Yellow_Disable>
			EAST_WEST_GREENDisable();
    1f80:	0e 94 9e 0e 	call	0x1d3c	; 0x1d3c <EAST_WEST_GREENDisable>
			vTaskDelay(5000); // Green for 5 seconds
    1f84:	88 e8       	ldi	r24, 0x88	; 136
    1f86:	93 e1       	ldi	r25, 0x13	; 19
    1f88:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vTaskDelay>
			// North-South Yellow
			Yellow_Enable();
    1f8c:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <Yellow_Enable>

			vTaskDelay(2000 ); // Yellow for 2 seconds
    1f90:	80 ed       	ldi	r24, 0xD0	; 208
    1f92:	97 e0       	ldi	r25, 0x07	; 7
    1f94:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vTaskDelay>
			// EAST-WEST GREEN
			North_South_GreenDisable();
    1f98:	0e 94 b2 0e 	call	0x1d64	; 0x1d64 <North_South_GreenDisable>
			Yellow_Disable();
    1f9c:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <Yellow_Disable>
			EAST_WEST_GREENEnable();
    1fa0:	0e 94 a3 0e 	call	0x1d46	; 0x1d46 <EAST_WEST_GREENEnable>
			vTaskDelay(5000 ); // Red for 5 seconds
    1fa4:	88 e8       	ldi	r24, 0x88	; 136
    1fa6:	93 e1       	ldi	r25, 0x13	; 19
    1fa8:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vTaskDelay>
			// EAST-WEST Yellow

			Yellow_Enable();
    1fac:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <Yellow_Enable>
			vTaskDelay(2000 ); // Yellow for 2 seconds
    1fb0:	80 ed       	ldi	r24, 0xD0	; 208
    1fb2:	97 e0       	ldi	r25, 0x07	; 7
    1fb4:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vTaskDelay>
		}
		if (Flag == 2)
    1fb8:	80 91 67 00 	lds	r24, 0x0067
    1fbc:	82 30       	cpi	r24, 0x02	; 2
    1fbe:	c1 f6       	brne	.-80     	; 0x1f70 <trafficLightControlTask>
		{
			North_South_GreenDisable();
    1fc0:	0e 94 b2 0e 	call	0x1d64	; 0x1d64 <North_South_GreenDisable>
			Yellow_Disable();
    1fc4:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <Yellow_Disable>
			EAST_WEST_GREENEnable();
    1fc8:	0e 94 a3 0e 	call	0x1d46	; 0x1d46 <EAST_WEST_GREENEnable>
			vTaskDelay(5000 ); // Red for 5 seconds
    1fcc:	88 e8       	ldi	r24, 0x88	; 136
    1fce:	93 e1       	ldi	r25, 0x13	; 19
    1fd0:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vTaskDelay>
			// EAST-WEST Yellow
			Yellow_Enable();
    1fd4:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <Yellow_Enable>
			vTaskDelay(2000 ); // Yellow for 2 seconds
    1fd8:	80 ed       	ldi	r24, 0xD0	; 208
    1fda:	97 e0       	ldi	r25, 0x07	; 7
    1fdc:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vTaskDelay>

			North_South_GreenEnable();
    1fe0:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <North_South_GreenEnable>
			Yellow_Disable();
    1fe4:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <Yellow_Disable>
			EAST_WEST_GREENDisable();
    1fe8:	0e 94 9e 0e 	call	0x1d3c	; 0x1d3c <EAST_WEST_GREENDisable>
			vTaskDelay(5000); // Green for 5 seconds
    1fec:	88 e8       	ldi	r24, 0x88	; 136
    1fee:	93 e1       	ldi	r25, 0x13	; 19
    1ff0:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vTaskDelay>

			// North-South Yellow
			Yellow_Enable();
    1ff4:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <Yellow_Enable>

			vTaskDelay(2000 ); // Yellow for 2 seconds
    1ff8:	80 ed       	ldi	r24, 0xD0	; 208
    1ffa:	97 e0       	ldi	r25, 0x07	; 7
    1ffc:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vTaskDelay>
    2000:	b7 cf       	rjmp	.-146    	; 0x1f70 <trafficLightControlTask>

00002002 <button_task2>:

// CREATE TASK FOR BUTTON 2
void button_task2(void *pvParameters)
{
	// CHECK semaphore TAKE KEY OR NO
	if(xSemaphoreTake(LCD_KEY,0) == pdPASS)
    2002:	80 91 eb 06 	lds	r24, 0x06EB
    2006:	90 91 ec 06 	lds	r25, 0x06EC
    200a:	60 e0       	ldi	r22, 0x00	; 0
    200c:	70 e0       	ldi	r23, 0x00	; 0
    200e:	40 e0       	ldi	r20, 0x00	; 0
    2010:	50 e0       	ldi	r21, 0x00	; 0
    2012:	20 e0       	ldi	r18, 0x00	; 0
    2014:	0e 94 20 07 	call	0xe40	; 0xe40 <xQueueGenericReceive>
    2018:	81 30       	cpi	r24, 0x01	; 1
    201a:	91 f5       	brne	.+100    	; 0x2080 <button_task2+0x7e>
	{

		Yellow_Disable();
    201c:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <Yellow_Disable>
		EAST_WEST_GREENDisable();
    2020:	0e 94 9e 0e 	call	0x1d3c	; 0x1d3c <EAST_WEST_GREENDisable>
		North_South_GreenDisable();
    2024:	0e 94 b2 0e 	call	0x1d64	; 0x1d64 <North_South_GreenDisable>
		vSET_PIN_OUTPUT_VALUE(PORT_D,PIN_7, HIGH);
    2028:	83 e0       	ldi	r24, 0x03	; 3
    202a:	67 e0       	ldi	r22, 0x07	; 7
    202c:	41 e0       	ldi	r20, 0x01	; 1
    202e:	0e 94 5f 01 	call	0x2be	; 0x2be <vSET_PIN_OUTPUT_VALUE>
		vSET_PIN_OUTPUT_VALUE(PORT_D,PIN_6, LOW);
    2032:	83 e0       	ldi	r24, 0x03	; 3
    2034:	66 e0       	ldi	r22, 0x06	; 6
    2036:	40 e0       	ldi	r20, 0x00	; 0
    2038:	0e 94 5f 01 	call	0x2be	; 0x2be <vSET_PIN_OUTPUT_VALUE>

		Yellow_Enable();
    203c:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <Yellow_Enable>
		vTaskDelay(1000 );
    2040:	88 ee       	ldi	r24, 0xE8	; 232
    2042:	93 e0       	ldi	r25, 0x03	; 3
    2044:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vTaskDelay>
		Yellow_Disable();
    2048:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <Yellow_Disable>
		North_South_GreenEnable();
    204c:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <North_South_GreenEnable>
		vTaskDelay(2000 );
    2050:	80 ed       	ldi	r24, 0xD0	; 208
    2052:	97 e0       	ldi	r25, 0x07	; 7
    2054:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vTaskDelay>
		Yellow_Enable();
    2058:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <Yellow_Enable>
		vTaskDelay(1000 );
    205c:	88 ee       	ldi	r24, 0xE8	; 232
    205e:	93 e0       	ldi	r25, 0x03	; 3
    2060:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vTaskDelay>
		Flag = 2;
    2064:	82 e0       	ldi	r24, 0x02	; 2
    2066:	80 93 67 00 	sts	0x0067, r24
		// after finish Give semaphore
		xSemaphoreGive(LCD_KEY);
    206a:	80 91 eb 06 	lds	r24, 0x06EB
    206e:	90 91 ec 06 	lds	r25, 0x06EC
    2072:	60 e0       	ldi	r22, 0x00	; 0
    2074:	70 e0       	ldi	r23, 0x00	; 0
    2076:	40 e0       	ldi	r20, 0x00	; 0
    2078:	50 e0       	ldi	r21, 0x00	; 0
    207a:	20 e0       	ldi	r18, 0x00	; 0
    207c:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <xQueueGenericSend>
	}
	// Walk signal for 5 seconds
	vSET_PIN_OUTPUT_VALUE(PORT_D,PIN_7, LOW);
    2080:	83 e0       	ldi	r24, 0x03	; 3
    2082:	67 e0       	ldi	r22, 0x07	; 7
    2084:	40 e0       	ldi	r20, 0x00	; 0
    2086:	0e 94 5f 01 	call	0x2be	; 0x2be <vSET_PIN_OUTPUT_VALUE>
	vSET_PIN_OUTPUT_VALUE(PORT_D,PIN_6, HIGH);
    208a:	83 e0       	ldi	r24, 0x03	; 3
    208c:	66 e0       	ldi	r22, 0x06	; 6
    208e:	41 e0       	ldi	r20, 0x01	; 1
    2090:	0e 94 5f 01 	call	0x2be	; 0x2be <vSET_PIN_OUTPUT_VALUE>
	// DELETE TASK AFTER COMPLETE
	vTaskDelete( NULL );
    2094:	80 e0       	ldi	r24, 0x00	; 0
    2096:	90 e0       	ldi	r25, 0x00	; 0
    2098:	0e 94 c4 0c 	call	0x1988	; 0x1988 <vTaskDelete>
}
    209c:	08 95       	ret

0000209e <button_task1>:
xSemaphoreHandle LCD_KEY;
volatile u8 Flag = 1;
volatile u8 Flag1 = 4;
// CREATE TASK FOR BUTTON 1
void button_task1(void *pvParameters)
{
    209e:	1f 93       	push	r17

	// CHECK semaphore TAKE KEY OR NO
	if(xSemaphoreTake(LCD_KEY,0) == pdPASS)
    20a0:	80 91 eb 06 	lds	r24, 0x06EB
    20a4:	90 91 ec 06 	lds	r25, 0x06EC
    20a8:	60 e0       	ldi	r22, 0x00	; 0
    20aa:	70 e0       	ldi	r23, 0x00	; 0
    20ac:	40 e0       	ldi	r20, 0x00	; 0
    20ae:	50 e0       	ldi	r21, 0x00	; 0
    20b0:	20 e0       	ldi	r18, 0x00	; 0
    20b2:	0e 94 20 07 	call	0xe40	; 0xe40 <xQueueGenericReceive>
    20b6:	18 2f       	mov	r17, r24
    20b8:	81 30       	cpi	r24, 0x01	; 1
    20ba:	89 f5       	brne	.+98     	; 0x211e <button_task1+0x80>
	{
		Yellow_Disable();
    20bc:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <Yellow_Disable>
		EAST_WEST_GREENDisable();
    20c0:	0e 94 9e 0e 	call	0x1d3c	; 0x1d3c <EAST_WEST_GREENDisable>
		North_South_GreenDisable();
    20c4:	0e 94 b2 0e 	call	0x1d64	; 0x1d64 <North_South_GreenDisable>
		vSET_PIN_OUTPUT_VALUE(PORT_D,PIN_5, HIGH);
    20c8:	83 e0       	ldi	r24, 0x03	; 3
    20ca:	65 e0       	ldi	r22, 0x05	; 5
    20cc:	41 e0       	ldi	r20, 0x01	; 1
    20ce:	0e 94 5f 01 	call	0x2be	; 0x2be <vSET_PIN_OUTPUT_VALUE>

		vSET_PIN_OUTPUT_VALUE(PORT_D,PIN_4, LOW);
    20d2:	83 e0       	ldi	r24, 0x03	; 3
    20d4:	64 e0       	ldi	r22, 0x04	; 4
    20d6:	40 e0       	ldi	r20, 0x00	; 0
    20d8:	0e 94 5f 01 	call	0x2be	; 0x2be <vSET_PIN_OUTPUT_VALUE>

		Yellow_Enable();
    20dc:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <Yellow_Enable>
		vTaskDelay(1000 );
    20e0:	88 ee       	ldi	r24, 0xE8	; 232
    20e2:	93 e0       	ldi	r25, 0x03	; 3
    20e4:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vTaskDelay>
		Yellow_Disable();
    20e8:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <Yellow_Disable>
		EAST_WEST_GREENEnable();
    20ec:	0e 94 a3 0e 	call	0x1d46	; 0x1d46 <EAST_WEST_GREENEnable>
		vTaskDelay(2000 );
    20f0:	80 ed       	ldi	r24, 0xD0	; 208
    20f2:	97 e0       	ldi	r25, 0x07	; 7
    20f4:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vTaskDelay>
		Yellow_Enable();
    20f8:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <Yellow_Enable>
		vTaskDelay(1000 );
    20fc:	88 ee       	ldi	r24, 0xE8	; 232
    20fe:	93 e0       	ldi	r25, 0x03	; 3
    2100:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vTaskDelay>
		// after finish Give semaphore
		xSemaphoreGive(LCD_KEY);
    2104:	80 91 eb 06 	lds	r24, 0x06EB
    2108:	90 91 ec 06 	lds	r25, 0x06EC
    210c:	60 e0       	ldi	r22, 0x00	; 0
    210e:	70 e0       	ldi	r23, 0x00	; 0
    2110:	40 e0       	ldi	r20, 0x00	; 0
    2112:	50 e0       	ldi	r21, 0x00	; 0
    2114:	20 e0       	ldi	r18, 0x00	; 0
    2116:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <xQueueGenericSend>
		Flag=1;
    211a:	10 93 67 00 	sts	0x0067, r17
	}
	// Walk signal for 5 seconds
	vSET_PIN_OUTPUT_VALUE(PORT_D,PIN_5, LOW);
    211e:	83 e0       	ldi	r24, 0x03	; 3
    2120:	65 e0       	ldi	r22, 0x05	; 5
    2122:	40 e0       	ldi	r20, 0x00	; 0
    2124:	0e 94 5f 01 	call	0x2be	; 0x2be <vSET_PIN_OUTPUT_VALUE>
	vSET_PIN_OUTPUT_VALUE(PORT_D,PIN_4, HIGH);
    2128:	83 e0       	ldi	r24, 0x03	; 3
    212a:	64 e0       	ldi	r22, 0x04	; 4
    212c:	41 e0       	ldi	r20, 0x01	; 1
    212e:	0e 94 5f 01 	call	0x2be	; 0x2be <vSET_PIN_OUTPUT_VALUE>
	// DELETE TASK AFTER COMPLETE
	vTaskDelete( NULL );
    2132:	80 e0       	ldi	r24, 0x00	; 0
    2134:	90 e0       	ldi	r25, 0x00	; 0
    2136:	0e 94 c4 0c 	call	0x1988	; 0x1988 <vTaskDelete>
}
    213a:	1f 91       	pop	r17
    213c:	08 95       	ret

0000213e <memcpy>:
    213e:	fb 01       	movw	r30, r22
    2140:	dc 01       	movw	r26, r24
    2142:	02 c0       	rjmp	.+4      	; 0x2148 <memcpy+0xa>
    2144:	01 90       	ld	r0, Z+
    2146:	0d 92       	st	X+, r0
    2148:	41 50       	subi	r20, 0x01	; 1
    214a:	50 40       	sbci	r21, 0x00	; 0
    214c:	d8 f7       	brcc	.-10     	; 0x2144 <memcpy+0x6>
    214e:	08 95       	ret

00002150 <memset>:
    2150:	dc 01       	movw	r26, r24
    2152:	01 c0       	rjmp	.+2      	; 0x2156 <memset+0x6>
    2154:	6d 93       	st	X+, r22
    2156:	41 50       	subi	r20, 0x01	; 1
    2158:	50 40       	sbci	r21, 0x00	; 0
    215a:	e0 f7       	brcc	.-8      	; 0x2154 <memset+0x4>
    215c:	08 95       	ret

0000215e <strncpy>:
    215e:	fb 01       	movw	r30, r22
    2160:	dc 01       	movw	r26, r24
    2162:	41 50       	subi	r20, 0x01	; 1
    2164:	50 40       	sbci	r21, 0x00	; 0
    2166:	48 f0       	brcs	.+18     	; 0x217a <strncpy+0x1c>
    2168:	01 90       	ld	r0, Z+
    216a:	0d 92       	st	X+, r0
    216c:	00 20       	and	r0, r0
    216e:	c9 f7       	brne	.-14     	; 0x2162 <strncpy+0x4>
    2170:	01 c0       	rjmp	.+2      	; 0x2174 <strncpy+0x16>
    2172:	1d 92       	st	X+, r1
    2174:	41 50       	subi	r20, 0x01	; 1
    2176:	50 40       	sbci	r21, 0x00	; 0
    2178:	e0 f7       	brcc	.-8      	; 0x2172 <strncpy+0x14>
    217a:	08 95       	ret

0000217c <_exit>:
    217c:	f8 94       	cli

0000217e <__stop_program>:
    217e:	ff cf       	rjmp	.-2      	; 0x217e <__stop_program>
